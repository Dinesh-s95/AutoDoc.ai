This document provides a comprehensive detailed design analysis of the Enrollment Application, a Java Spring Boot application. It includes class-by-class analysis, runtime view diagrams, entity relationship diagrams, and detailed component interactions.

== Class-by-Class Analysis

=== EnrollmentApplication

[source,java]
----
@EnableFeignClients
@SpringBootApplication
public class EnrollmentApplication {
    public static void main(String[] args) {
        SpringApplication.run(EnrollmentApplication.class, args);
    }
}
----

*Purpose*: This is the main entry point of the Spring Boot application. It initializes and runs the application context.

*Annotations*:
- `@EnableFeignClients`: Enables the discovery of interfaces that declare they are Feign clients (used for making REST calls).
- `@SpringBootApplication`: Indicates a configuration class that declares one or more `@Bean` methods and also triggers auto-configuration and component scanning.

*Methods*:
- `main(String[] args)`: The main method which Spring Boot uses to start the application.

=== UserManagementClient

[source,java]
----
@FeignClient(name = "UserClient", url = "http://userapi.com")
public interface UserManagementClient {
    @GetMapping("/users")
    UserResponseDTO getUserByUsername(@RequestParam("username") String username);
}
----

*Purpose*: Interface for making REST calls to the user management API using Feign.

*Annotations*:
- `@FeignClient`: Declares that this interface is a Feign client. `name` is an arbitrary client name, which is used to create a Ribbon load balancer.
- `@GetMapping`: Maps HTTP GET requests onto specific handler methods. Here it is used to define the endpoint for getting user details by username.
- `@RequestParam`: Indicates that a method parameter should be bound to a web request parameter.

=== EnrollmentController

[source,java]
----
@RestController
@RequestMapping("/enrollment")
public class EnrollmentController {
    @Autowired
    private EnrollmentService service;

    @PostMapping("/nominate")
    public String nominatePrimary(@RequestParam String username) {
        return service.nominatePrimaryUser(username);
    }
}
----

*Purpose*: Provides web endpoints for handling enrollment related HTTP requests.

*Annotations*:
- `@RestController`: Indicates that the data returned by each method will be written straight into the response body instead of rendering a template.
- `@RequestMapping`: Declares that all APIs in this controller will be accessed under the `/enrollment` path.
- `@PostMapping`: Maps HTTP POST requests onto specific handler methods.
- `@Autowired`: Marks a constructor, field, setter method, or config method to be autowired by Spring's dependency injection facilities.

*Methods*:
- `nominatePrimary(String username)`: Handles the nomination of a primary user by delegating to the `EnrollmentService`.

=== UserResponseDTO

[source,java]
----
@Getter
@Setter
public class UserResponseDTO {
    private String mobilityUserId;
    private String username;
    private String vin;
}
----

*Purpose*: Data Transfer Object (DTO) for transferring user data.

*Annotations*:
- `@Getter`: Lombok annotation to generate getters for all fields.
- `@Setter`: Lombok annotation to generate setters for all fields.

=== Enrollment

[source,java]
----
@Entity
@Getter
@Setter
public class Enrollment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String role;
    private String username;
    private String vin;
}
----

*Purpose*: Represents the Enrollment entity in the database.

*Annotations*:
- `@Entity`: Specifies that the class is an entity and is mapped to a database table.
- `@Id`: Specifies the primary key of an entity.
- `@GeneratedValue`: Provides the specification of generation strategies for the values of primary keys.
- `@Getter` / `@Setter`: Lombok annotations to generate getters and setters for all fields.

=== EnrollmentRepository

[source,java]
----
public interface EnrollmentRepository extends JpaRepository<Enrollment, Long> {
}
----

*Purpose*: Repository interface for `Enrollment` entity, extending Spring Data JPA.

=== EnrollmentService

[source,java]
----
@Service
public class EnrollmentService {
    @Autowired
    private EnrollmentRepository repo;
    @Autowired
    private UserManagementClient userClient;

    public String nominatePrimaryUser(String username) {
        UserResponseDTO user = userClient.getUserByUsername(username);
        Enrollment enrollment = new Enrollment();
        enrollment.setUsername(username);
        enrollment.setRole("PRIMARY");
        enrollment.setVin(user.getVin());
        repo.save(enrollment);
        return "User nominated as primary";
    }
}
----

*Purpose*: Service layer to handle business logic for enrollment processes.

*Annotations*:
- `@Service`: Indicates that the class is a service provider.
- `@Autowired`: Marks the automatic injection of the `EnrollmentRepository` and `UserManagementClient` dependencies.

*Methods*:
- `nominatePrimaryUser(String username)`: Retrieves user details from the `UserManagementClient`, creates a new `Enrollment` entity, and saves it to the database.

=== EnrollmentApplicationTests

[source,java]
----
@SpringBootTest
public class EnrollmentApplicationTests {
    @Test
    public void contextLoads() {
    }
}
----

*Purpose*: Basic integration test to ensure the application context loads properly.

*Annotations*:
- `@SpringBootTest`: Used to provide a bridge between Spring Boot test features and JUnit. Whenever we are using Spring Boot in our application, this annotation will find the main configuration class (one with `@SpringBootApplication`) and use it to start a Spring application context.

== Runtime View Diagrams

=== User Registration Flow

[plantuml, user-registration-sequence, png]
----
@startuml
actor User
participant "EnrollmentController" as Controller
participant "EnrollmentService" as Service
participant "EnrollmentRepository" as Repository

User -> Controller : nominatePrimary(username)
Controller -> Service : nominatePrimaryUser(username)
Service -> Repository : save(enrollment)
Repository --> Service : enrollment
Service --> Controller : "User nominated as primary"
Controller --> User : "User nominated as primary"
@enduml
----

=== Authentication/Login Flow

[plantuml, authentication-sequence, png]
----
@startuml
actor User
participant "AuthenticationController" as AuthController
participant "AuthenticationService" as AuthService
participant "UserRepository" as UserRepo

User -> AuthController : login(credentials)
AuthController -> AuthService : authenticate(credentials)
AuthService -> UserRepo : findByUsername(username)
UserRepo --> AuthService : user
AuthService --> AuthController : token
AuthController --> User : token
@enduml
----

=== JWT Token Validation Flow

[plantuml, jwt-validation-sequence, png]
----
@startuml
actor User
participant "JWTFilter" as Filter
participant "TokenProvider" as TokenProvider

User -> Filter : request(resource)
Filter -> TokenProvider : validateToken(token)
TokenProvider --> Filter : isValid
Filter --> User : proceed / error
@enduml
----

== Entity Relationship Diagram

[plantuml, entity-relationship-diagram, png]
----
@startuml
entity "Enrollment" {
    * id : Long
    --
    * role : String
    * username : String
    * vin : String
}

entity "User" {
    * id : Long
    --
    * username : String
    * password : String
}

Enrollment "0..*" -- "1" User : "has"
@enduml
----

== Detailed Component Interactions

=== Controller-Service-Repository Interactions

- `EnrollmentController` receives HTTP requests and delegates to `EnrollmentService`.
- `EnrollmentService` handles business logic, interacts with `UserManagementClient` to fetch user details, and uses `EnrollmentRepository` to persist data.
- `EnrollmentRepository` extends `JpaRepository`, providing CRUD operations and database interaction.

=== Data Flow Through Layers

- Data flows from the controller to the service where business logic is applied. Then, data is either fetched or persisted through the repository layer, interacting with the database.

=== Exception Propagation

- Exceptions are thrown at the repository or service layer and are propagated up to the controller where they are handled and appropriate HTTP responses are generated.

=== Transaction Boundaries

- Transactions are typically started at the service layer ensuring that all operations within a single service method are completed successfully before the transaction is committed.

This detailed design document should provide developers with a clear understanding of the application's architecture, data flow, and interactions between components.