= Detailed Design Documentation for Enrollment Application

== Introduction

This document provides a detailed design overview of the Enrollment Application, focusing on the Java Spring Boot implementation. It covers class-by-class analysis, runtime view diagrams, entity relationship diagrams, and detailed component interactions.

== Class-by-Class Analysis

=== EnrollmentApplication

[source,java]
----
@EnableFeignClients
@SpringBootApplication
public class EnrollmentApplication {
    public static void main(String[] args) {
        SpringApplication.run(EnrollmentApplication.class, args);
    }
}
----

*Purpose*: Serves as the entry point for the Spring Boot application.
*Annotations*:
- `@EnableFeignClients`: Enables Feign clients in the application, allowing for declarative REST client creation.
- `@SpringBootApplication`: Indicates a configuration class that declares one or more `@Bean` methods and also triggers auto-configuration and component scanning.

=== UserManagementClient

[source,java]
----
@FeignClient(name = "userClient", url = "http://usermanagement.com")
public interface UserManagementClient {
    @GetMapping("/users")
    UserResponseDTO getUserByUsername(@RequestParam("username") String username);
}
----

*Purpose*: Defines a Feign client for interacting with the User Management microservice.
*Annotations*:
- `@FeignClient`: Declares that this interface is a Feign client.
- `@GetMapping`: Maps HTTP GET requests onto specific handler methods.
- `@RequestParam`: Indicates a method parameter should be bound to a web request parameter.

=== EnrollmentController

[source,java]
----
@RestController
@RequestMapping("/enrollment")
public class EnrollmentController {
    @Autowired
    private EnrollmentService service;

    @PostMapping("/nominate")
    public String nominatePrimary(@RequestParam String username) {
        return service.nominatePrimaryUser(username);
    }
}
----

*Purpose*: Handles incoming HTTP requests related to enrollments.
*Annotations*:
- `@RestController`: Marks the class as a controller where every method returns a domain object instead of a view.
- `@RequestMapping`: Maps web requests onto methods in request-handling classes.
- `@PostMapping`: Maps HTTP POST requests onto specific handler methods.
- `@Autowired`: Marks a constructor, field, or setter method to be autowired by Spring's dependency injection facilities.

=== UserResponseDTO

[source,java]
----
@Getter
@Setter
public class UserResponseDTO {
    private String mobilityUserId;
    private String username;
    private String vin;
}
----

*Purpose*: Data Transfer Object for user information.
*Annotations*:
- `@Getter`: Lombok annotation to generate getters.
- `@Setter`: Lombok annotation to generate setters.

=== Enrollment

[source,java]
----
@Entity
@Getter
@Setter
public class Enrollment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String role;
    private String username;
    private String vin;
}
----

*Purpose*: Represents the enrollment entity in the database.
*Annotations*:
- `@Entity`: Specifies that the class is an entity and is mapped to a database table.
- `@Id`: Specifies the primary key of an entity.
- `@GeneratedValue`: Provides for the specification of generation strategies for the values of primary keys.

=== EnrollmentRepository

[source,java]
----
public interface EnrollmentRepository extends JpaRepository<Enrollment, Long> {
}
----

*Purpose*: Repository interface for `Enrollment` entity, leveraging Spring Data JPA.

=== EnrollmentService

[source,java]
----
@Service
public class EnrollmentService {
    @Autowired
    private EnrollmentRepository repo;
    @Autowired
    private UserManagementClient userClient;

    public String nominatePrimaryUser(String username) {
        UserResponseDTO user = userClient.getUserByUsername(username);
        Enrollment enrollment = new Enrollment();
        enrollment.setUsername(username);
        enrollment.setRole("Primary");
        repo.save(enrollment);
        return "Nomination Successful";
    }
}
----

*Purpose*: Service layer to handle business logic for enrollment operations.
*Annotations*:
- `@Service`: Indicates that an annotated class is a "Service", originally defined by Domain-Driven Design (DDD) as "an operation offered as an interface that stands alone in the model, with no encapsulated state."
- `@Autowired`: Allows Spring to resolve and inject collaborating beans into our bean.

=== EnrollmentApplicationTests

[source,java]
----
@SpringBootTest
public class EnrollmentApplicationTests {
    @Test
    public void contextLoads() {
    }
}
----

*Purpose*: Basic integration test to ensure the Spring context loads properly.
*Annotations*:
- `@SpringBootTest`: Provides a bridge between Spring Boot test features and JUnit. Whenever we are using Spring Boot in our application, this annotation will find the main configuration class (one with `@SpringBootApplication` for instance) and use that to start a Spring application context.

== Runtime View Diagrams

=== User Registration Flow

[plantuml, user-registration-sequence, png]
----
@startuml
actor "User" as user
participant "EnrollmentController" as controller
participant "EnrollmentService" as service
participant "EnrollmentRepository" as repo

user -> controller : nominatePrimary(username)
controller -> service : nominatePrimaryUser(username)
service -> repo : save(enrollment)
repo -> service : return
service -> controller : return "Nomination Successful"
controller -> user : return "Nomination Successful"
@enduml
----

=== Authentication/Login Flow

[plantuml, authentication-sequence, png]
----
@startuml
actor "User" as user
participant "AuthenticationController" as authController
participant "AuthenticationService" as authService
participant "UserRepository" as userRepo

user -> authController : login(username, password)
authController -> authService : authenticate(username, password)
authService -> userRepo : findByUsername(username)
userRepo -> authService : user
authService -> authController : return token
authController -> user : return token
@enduml
----

=== JWT Token Validation Flow

[plantuml, jwt-validation-sequence, png]
----
@startuml
actor "User" as user
participant "JWTFilter" as jwtFilter
participant "JWTUtil" as jwtUtil

user -> jwtFilter : request(resource)
jwtFilter -> jwtUtil : validateToken(token)
jwtUtil -> jwtFilter : return isValid
jwtFilter -> user : proceed / error
@enduml
----

== Entity Relationship Diagram

[plantuml, entity-relationship-diagram, png]
----
@startuml
entity "Enrollment" {
    *id : Long
    --
    *role : String
    *username : String
    *vin : String
}
@enduml
----

== Detailed Component Interactions

=== Controller-Service-Repository Interactions

- **EnrollmentController**:
  - Receives HTTP requests and delegates to **EnrollmentService**.
  - Uses **@Autowired** to inject **EnrollmentService**.

- **EnrollmentService**:
  - Handles business logic and interacts with **EnrollmentRepository** and **UserManagementClient**.
  - Uses **@Autowired** to inject both **EnrollmentRepository** and **UserManagementClient**.
  - Persists data using **EnrollmentRepository**.

- **EnrollmentRepository**:
  - Extends `JpaRepository`, providing CRUD operations for **Enrollment** entity.

=== Data Flow Through Layers

1. **Controller** receives HTTP request.
2. **Service** handles business logic, possibly fetching or persisting data via **Repository**.
3. **Repository** interacts with the database.
4. Data flows back from **Repository** to **Service**, then to **Controller**, and finally back to the client.

=== Exception Propagation

- Exceptions can occur at any layer.
- Typically handled globally by a **ControllerAdvice** class, providing a centralized exception handling mechanism.

=== Transaction Boundaries

- Defined at the service layer, ensuring that database operations either complete entirely or rollback in case of an error.
- Spring manages transactions declaratively using the **@Transactional** annotation.

== Conclusion

This document provides a comprehensive detailed design overview of the Enrollment Application, suitable for developers to understand and implement the specified functionalities effectively.