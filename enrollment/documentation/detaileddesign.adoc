= Detailed Design Documentation for Enrollment System

This document provides a comprehensive detailed design analysis of the Enrollment System developed using Java Spring Boot. It includes class-by-class analysis, runtime view diagrams, entity relationship diagrams, and detailed component interactions.

== 1. Class-by-Class Analysis

=== EnrollmentApplication

[source,java]
----
@SpringBootApplication
@EnableFeignClients
public class EnrollmentApplication {
    public static void main(String[] args) {
        SpringApplication.run(EnrollmentApplication.class, args);
    }
}
----

*Purpose*: This is the main entry point of the Spring Boot application. It initializes and runs the application context.

*Annotations*:
- `@SpringBootApplication`: Serves as a convenience annotation that adds all of the following:
  - `@Configuration`: Tags the class as a source of bean definitions for the application context.
  - `@EnableAutoConfiguration`: Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings.
  - `@ComponentScan`: Tells Spring to look for other components, configurations, and services in the specified package, allowing it to find and register the controllers.
- `@EnableFeignClients`: Enables Feign clients. This is used to create dynamic implementations of interfaces that can communicate with REST services.

=== UserManagementClient

[source,java]
----
@FeignClient(name = "UserClient", url = "http://usermanagement.com")
public interface UserManagementClient {
    @GetMapping("/users")
    UserResponseDTO getUserByUsername(@RequestParam("username") String username);
}
----

*Purpose*: This interface is used to communicate with the User Management microservice to fetch user details.

*Annotations*:
- `@FeignClient`: Declares that this interface is a Feign client and should be used to make REST calls to external services.
- `@GetMapping`: Indicates that the `getUserByUsername` method should make a GET request.
- `@RequestParam`: Indicates that the username should be passed as a request parameter to the GET request.

=== EnrollmentController

[source,java]
----
@RestController
@RequestMapping("/enrollment")
public class EnrollmentController {

    @Autowired
    private EnrollmentService service;

    @PostMapping("/nominate-primary")
    public String nominatePrimary(@RequestParam String username) {
        return service.nominatePrimaryUser(username);
    }

    @PostMapping("/nominate-secondary")
    public String nominateSecondary(@RequestParam String username) {
        return service.nominateSecondaryUser(username);
    }
}
----

*Purpose*: This class handles HTTP requests related to enrollment operations.

*Annotations*:
- `@RestController`: Marks the class as a controller where every method returns a domain object instead of a view.
- `@RequestMapping`: Maps HTTP requests to handler methods of MVC and REST controllers.
- `@Autowired`: Marks a constructor, field, setter method, or config method to be autowired by Spring's dependency injection facilities.
- `@PostMapping`: Marks a method to handle POST type of request method.

*Methods*:
- `nominatePrimary`: Handles the nomination of a primary user.
- `nominateSecondary`: Handles the nomination of a secondary user.

=== UserResponseDTO

[source,java]
----
@Getter
@Setter
public class UserResponseDTO {
    private String mobilityUserId;
    private String username;
    private String vin;
}
----

*Purpose*: This class serves as a Data Transfer Object for user information.

*Annotations*:
- `@Getter`: Lombok annotation to generate getters.
- `@Setter`: Lombok annotation to generate setters.

=== Enrollment

[source,java]
----
@Entity
@Getter
@Setter
public class Enrollment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String role;
    private String username;
    private String vin;
}
----

*Purpose*: Represents the enrollment entity in the database.

*Annotations*:
- `@Entity`: Specifies that the class is an entity and is mapped to a database table.
- `@Id`: Specifies the primary key of an entity.
- `@GeneratedValue`: Provides the specification of generation strategies for the values of primary keys.

=== EnrollmentRepository

[source,java]
----
public interface EnrollmentRepository extends JpaRepository<Enrollment, Long> {
}
----

*Purpose*: Repository interface for `Enrollment` that extends Spring Data JPA's `JpaRepository`, providing CRUD operations.

=== EnrollmentService

[source,java]
----
@Service
public class EnrollmentService {

    @Autowired
    private EnrollmentRepository repo;
    @Autowired
    private UserManagementClient userClient;

    public String nominatePrimaryUser(String username) {
        UserResponseDTO user = userClient.getUserByUsername(username);
        Enrollment enrollment = new Enrollment();
        enrollment.setUsername(username);
        enrollment.setRole("PRIMARY");
        repo.save(enrollment);
        return "User nominated as primary";
    }
}
----

*Purpose*: Service class for managing enrollment operations.

*Annotations*:
- `@Service`: Indicates that the class holds business logic and calls methods in the repository layer.
- `@Autowired`: Injects object dependency implicitly.

*Methods*:
- `nominatePrimaryUser`: Nominates a user as primary by saving the user's details in the database.

=== EnrollmentApplicationTests

[source,java]
----
@SpringBootTest
public class EnrollmentApplicationTests {

    @Test
    public void contextLoads() {
    }
}
----

*Purpose*: Class for testing the Spring Boot application context.

*Annotations*:
- `@SpringBootTest`: Provides support for loading a Spring ApplicationContext and having beans `@Autowired` into your test instance.
- `@Test`: Marks a method to be testable.

== 2. Runtime View Diagrams

=== User Registration Flow

[plantuml, user-registration-flow, png]
----
@startuml
actor "User" as U
participant "EnrollmentController" as EC
participant "EnrollmentService" as ES
participant "EnrollmentRepository" as ER

U -> EC : register(username, details)
EC -> ES : registerUser(username, details)
ES -> ER : save(new Enrollment)
ER -> ES : return saved Enrollment
ES -> EC : return result
EC -> U : display result
@enduml
----

=== Authentication/Login Flow

[plantuml, authentication-flow, png]
----
@startuml
actor "User" as U
participant "AuthenticationController" as AC
participant "AuthenticationService" as AS
participant "UserRepository" as UR

U -> AC : login(username, password)
AC -> AS : authenticate(username, password)
AS -> UR : findByUsername(username)
UR -> AS : return User
AS -> AS : verify password
AS -> AC : return authentication result
AC -> U : display result
@enduml
----

=== JWT Token Validation Flow

[plantuml, jwt-validation-flow, png]
----
@startuml
actor "User" as U
participant "JWTFilter" as JF
participant "JWTService" as JS

U -> JF : request(resource)
JF -> JS : validateToken(token)
JS -> JS : decode token
JS -> JF : return validation result
JF -> JF : grant/deny access
JF -> U : response
@enduml
----

== 3. Entity Relationship Diagram

[plantuml, er-diagram, png]
----
@startuml
entity "User" {
    * id : int
    --
    * username : varchar
    * password : varchar
}

entity "Enrollment" {
    * id : int
    --
    * role : varchar
    * username : varchar
    * vin : varchar
}

User ||..|| Enrollment : "has"
@enduml
----

*User*: Represents the user of the system. Each user has a unique id, a username, and a password.

*Enrollment*: Represents an enrollment record in the system. Each enrollment has a unique id, a role (primary or secondary), a username (linked to User), and a vehicle identification number (VIN).

== 4. Detailed Component Interactions

=== Controller-Service-Repository Interactions

The `EnrollmentController` receives HTTP requests and delegates business operations to `EnrollmentService`. The service layer contains business logic and interacts with `EnrollmentRepository` to perform CRUD operations on the database.

=== Data Flow Through Layers

1. HTTP requests are received by the controllers.
2. Controllers call the appropriate service methods.
3. Service methods use repositories to interact with the database.
4. Data is returned back through the layers to the user.

=== Exception Propagation

Exceptions are thrown by the repository or service layers, which are then caught and handled in the controller layer. Appropriate HTTP responses are sent back to the client based on the exception type.

=== Transaction Boundaries

Transactions are managed at the service layer. Each public service method starts a new transaction, which is committed upon successful execution of the method or rolled back if an exception occurs.

This detailed design document provides a comprehensive overview of the system architecture, helping developers understand the implementation and interactions within the system.