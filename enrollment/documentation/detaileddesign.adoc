= Detailed Design Documentation for Enrollment System

This document provides a comprehensive detailed design overview of the Enrollment System implemented using Java Spring Boot. It includes class-by-class analysis, runtime view diagrams, entity relationship diagrams, and detailed component interactions.

== Class-by-Class Analysis

=== EnrollmentApplication

[source,java]
----
@EnableFeignClients
@SpringBootApplication
public class EnrollmentApplication {
    public static void main(String[] args) {
        SpringApplication.run(EnrollmentApplication.class, args);
    }
}
----

*Purpose*: The main entry point for the Spring Boot application. It initializes the application context and all Spring Boot components.

*Annotations*:
- `@EnableFeignClients`: Enables the discovery of interfaces that declare they are Feign clients (for making REST calls).
- `@SpringBootApplication`: Indicates a configuration class that declares one or more `@Bean` methods and also triggers auto-configuration and component scanning.

*Methods*:
- `main(String[] args)`: The main method that Spring Boot uses to start the application.

=== UserManagementClient

[source,java]
----
@FeignClient(name = "userClient", url = "http://usermanagement.com")
public interface UserManagementClient {
    @GetMapping("/users")
    UserResponseDTO getUserByUsername(@RequestParam("username") String username);
}
----

*Purpose*: Defines a Feign client for interacting with the User Management microservice.

*Annotations*:
- `@FeignClient`: Declares that this interface is a Feign client and specifies the name and URL of the service it connects to.
- `@GetMapping`: Maps HTTP GET requests onto specific handler methods. Used here to define a method for fetching user data by username.
- `@RequestParam`: Indicates that a method parameter should be bound to a web request parameter.

=== EnrollmentController

[source,java]
----
@RestController
@RequestMapping("/enrollment")
public class EnrollmentController {
    @Autowired
    private EnrollmentService service;

    @PostMapping("/nominate-primary")
    public String nominatePrimary(@RequestParam String username) {
        return service.nominatePrimaryUser(username);
    }

    @PostMapping("/nominate-secondary")
    public String nominateSecondary(@RequestParam String username) {
        return service.nominateSecondaryUser(username);
    }
}
----

*Purpose*: Handles all web requests related to enrollment processes such as nominating primary and secondary users.

*Annotations*:
- `@RestController`: Marks the class as a controller where every method returns a domain object instead of a view.
- `@RequestMapping`: Maps web requests onto specific handler classes and/or handler methods.
- `@Autowired`: Marks a constructor, field, setter method, or config method to be autowired by Spring's dependency injection facilities.
- `@PostMapping`: Maps HTTP POST requests onto specific handler methods.

*Methods*:
- `nominatePrimary(String username)`: Nominates a primary user.
- `nominateSecondary(String username)`: Nominates a secondary user.

=== UserResponseDTO

[source,java]
----
@Getter
@Setter
public class UserResponseDTO {
    private String mobilityUserId;
    private String username;
    private String vin;
}
----

*Purpose*: Data Transfer Object (DTO) for transferring user data between processes.

*Annotations*:
- `@Getter`: Lombok annotation to generate getters for all fields.
- `@Setter`: Lombok annotation to generate setters for all fields.

=== Enrollment

[source,java]
----
@Entity
@Getter
@Setter
public class Enrollment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String role;
    private String username;
    private String vin;
}
----

*Purpose*: Represents the enrollment entity in the database.

*Annotations*:
- `@Entity`: Specifies that the class is an entity and is mapped to a database table.
- `@Id`: Specifies the primary key of an entity.
- `@GeneratedValue`: Provides for the specification of generation strategies for the values of primary keys.
- `@Getter` and `@Setter`: Lombok annotations to generate getters and setters for all fields.

=== EnrollmentRepository

[source,java]
----
public interface EnrollmentRepository extends JpaRepository<Enrollment, Long> {
}
----

*Purpose*: Repository interface for `Enrollment` that extends Spring Data JPA's `JpaRepository`, providing CRUD operations on `Enrollment` entities.

=== EnrollmentService

[source,java]
----
@Service
public class EnrollmentService {
    @Autowired
    private EnrollmentRepository repo;
    @Autowired
    private UserManagementClient userClient;

    public String nominatePrimaryUser(String username) {
        // Implementation details
    }

    public String nominateSecondaryUser(String username) {
        // Implementation details
    }
}
----

*Purpose*: Service layer to handle the business logic of user enrollment.

*Annotations*:
- `@Service`: Indicates that the class holds business logic and can be autowired in other classes.
- `@Autowired`: Injects object dependency implicitly.

*Methods*:
- `nominatePrimaryUser(String username)`: Business logic to nominate a primary user.
- `nominateSecondaryUser(String username)`: Business logic to nominate a secondary user.

=== EnrollmentApplicationTests

[source,java]
----
@SpringBootTest
public class EnrollmentApplicationTests {
    @Test
    public void contextLoads() {
    }
}
----

*Purpose*: Basic integration test to ensure the Spring Application context loads correctly.

*Annotations*:
- `@SpringBootTest`: Used to provide a bridge between Spring Boot test features and JUnit. Whenever you are testing Spring Boot applications, this annotation will be useful.
- `@Test`: Denotes that a method is a test method.

== Runtime View Diagrams

=== User Registration Flow

[plantuml, user-registration-sequence, png]
----
@startuml
actor User
participant "EnrollmentController" as Controller
participant "EnrollmentService" as Service
participant "EnrollmentRepository" as Repository

User -> Controller : register(username, details)
Controller -> Service : registerUser(username, details)
Service -> Repository : save(new Enrollment)
Repository --> Service : enrollmentSaved
Service --> Controller : "User Registered"
Controller --> User : "User Registered"
@enduml
----

=== Authentication/Login Flow

[plantuml, authentication-sequence, png]
----
@startuml
actor User
participant "AuthenticationController" as Controller
participant "AuthenticationService" as Service
participant "UserRepository" as Repository

User -> Controller : login(username, password)
Controller -> Service : authenticate(username, password)
Service -> Repository : findByUsername(username)
Repository --> Service : user
Service --> Controller : generateToken(user)
Controller --> User : token
@enduml
----

=== JWT Token Validation Flow

[plantuml, jwt-validation-sequence, png]
----
@startuml
actor User
participant "SecurityFilter" as Filter
participant "TokenService" as TokenSvc

User -> Filter : request(resource)
Filter -> TokenSvc : validateToken(token)
TokenSvc --> Filter : isValid
Filter --> User : proceed / error
@enduml
----

=== Business Process Flow

[plantuml, business-process-flow, png]
----
@startuml
actor Client
participant "BusinessController" as Controller
participant "BusinessService" as Service
participant "BusinessRepository" as Repository

Client -> Controller : performAction(data)
Controller -> Service : initiateProcess(data)
Service -> Repository : updateEntity(entity)
Repository --> Service : updatedEntity
Service --> Controller : result
Controller --> Client : result
@enduml
----

=== Exception Handling Flow

[plantuml, exception-handling-flow, png]
----
@startuml
actor User
participant "EnrollmentController" as Controller
participant "EnrollmentService" as Service
participant "EnrollmentRepository" as Repository

User -> Controller : action()
Controller -> Service : performAction()
Service -> Repository : riskyCall()
Repository --> Service : throw new DatabaseException()
Service --> Controller : throw new ServiceException()
Controller --> User : "Error occurred"
@enduml
----

== Entity Relationship Diagram

[plantuml, entity-relationship-diagram, png]
----
@startuml
entity "Enrollment" {
    * id : Long
    --
    * role : String
    * username : String
    * vin : String
}

@enduml
----

=== Detailed Description of Entities and Relationships

The system consists of the following entities:

- **Enrollment**: Represents the enrollment records in the system. It contains fields such as `id` (primary key), `role`, `username`, and `vin`. The `Enrollment` entity does not have relationships with other entities in this simplified model.

== Detailed Component Interactions

=== Controller-Service-Repository Interactions

- **EnrollmentController**:
  - Receives HTTP requests from clients.
  - Delegates business processing to **EnrollmentService**.
  - Returns responses based on the outcomes provided by the Service layer.

- **EnrollmentService**:
  - Contains business logic.
  - Interacts with **EnrollmentRepository** to persist and retrieve data.
  - Handles business exceptions and communicates outcomes back to **EnrollmentController**.

- **EnrollmentRepository**:
  - Interface to the database.
  - Extends `JpaRepository`, providing methods to perform CRUD operations on the `Enrollment` entity.

=== Data Flow Through Layers

1. **Controller** receives a request.
2. **Controller** calls the appropriate method on **Service**.
3. **Service** performs business logic and calls **Repository** if data access/manipulation is needed.
4. **Repository** interacts with the database and returns data to **Service**.
5. **Service** processes the data and returns control to **Controller**.
6. **Controller** sends the response back to the client.

=== Exception Propagation

- Exceptions are typically thrown from the **Repository** (e.g., database errors) or during business logic execution in the **Service**.
- **Service** may catch and handle or rethrow custom exceptions.
- **Controller** handles exceptions by returning appropriate HTTP status codes and messages to the client.

=== Transaction Boundaries

- Transactions are managed at the **Service** layer, ensuring that database operations are completed successfully before committing the transaction.
- Spring's `@Transactional` annotation can be used on service methods to declare transaction boundaries.

This detailed design document should provide developers with a clear understanding of the system's architecture, interactions, and processes, facilitating effective development, maintenance, and troubleshooting.