= Detailed Design Documentation for Enrollment System

This document provides a comprehensive detailed design of the Enrollment System implemented using Java Spring Boot. It includes class-by-class analysis, runtime view diagrams, entity relationship diagrams, and detailed component interactions.

== 1. Class-by-Class Analysis

=== EnrollmentApplication

[source,java]
----
@EnableFeignClients
@SpringBootApplication
public class EnrollmentApplication {
    public static void main(String[] args) {
        SpringApplication.run(EnrollmentApplication.class, args);
    }
}
----

*Purpose*: This is the main class that bootstraps the Spring Boot application. It also enables Feign clients for making HTTP requests to other services.

*Annotations*:
- `@EnableFeignClients`: Allows the discovery of interfaces that declare they are Feign clients.
- `@SpringBootApplication`: Indicates a configuration class that declares one or more `@Bean` methods and also triggers auto-configuration and component scanning.

*Methods*:
- `main(String[] args)`: The entry point of the Spring Boot application.

=== UserManagementClient

[source,java]
----
@FeignClient(name = "UserManagementClient", url = "http://usermanagement.com")
public interface UserManagementClient {
    @GetMapping("/users")
    UserResponseDTO getUserByUsername(@RequestParam("username") String username);
}
----

*Purpose*: This interface is used to communicate with the User Management service.

*Annotations*:
- `@FeignClient`: Declares that this interface is a Feign client. It targets the User Management service.
- `@GetMapping`: Maps HTTP GET requests onto specific handler methods.
- `@RequestParam`: Indicates a method parameter should be bound to a web request parameter.

=== EnrollmentController

[source,java]
----
@RestController
@RequestMapping("/enrollment")
public class EnrollmentController {
    @Autowired
    private EnrollmentService service;

    @PostMapping("/nominate-primary")
    public String nominatePrimary(@RequestParam String username) {
        return service.nominatePrimaryUser(username);
    }

    @PostMapping("/nominate-secondary")
    public String nominateSecondary(@RequestParam String username) {
        return service.nominateSecondary(username);
    }
}
----

*Purpose*: Provides RESTful web services for enrollment operations such as nominating primary and secondary users.

*Annotations*:
- `@RestController`: Marks the class as a controller where every method returns a domain object instead of a view.
- `@RequestMapping`: Maps web requests onto methods in request-handling classes.
- `@Autowired`: Marks a constructor, field, setter method, or config method as to be autowired by Spring's dependency injection facilities.
- `@PostMapping`: Maps HTTP POST requests onto specific handler methods.

*Methods*:
- `nominatePrimary(String username)`: Nominates a primary user.
- `nominateSecondary(String username)`: Nominates a secondary user.

=== UserResponseDTO

[source,java]
----
@Getter
@Setter
public class UserResponseDTO {
    private String mobilityUserId;
    private String username;
    private String vin;
}
----

*Purpose*: Data Transfer Object (DTO) for transferring user data.

*Annotations*:
- `@Getter`: Lombok annotation to generate getters.
- `@Setter`: Lombok annotation to generate setters.

=== Enrollment

[source,java]
----
@Entity
@Getter
@Setter
public class Enrollment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String role;
    private String username;
    private String vin;
}
----

*Purpose*: Represents the enrollment entity.

*Annotations*:
- `@Entity`: Specifies that the class is an entity and is mapped to a database table.
- `@Id`: Specifies the primary key of an entity.
- `@GeneratedValue`: Provides for the specification of generation strategies for the values of primary keys.

=== EnrollmentRepository

[source,java]
----
public interface EnrollmentRepository extends JpaRepository<Enrollment, Long> {
}
----

*Purpose*: Repository interface for `Enrollment` that extends Spring Data JPA's `JpaRepository`, providing CRUD operations.

=== EnrollmentService

[source,java]
----
@Service
public class EnrollmentService {
    @Autowired
    private EnrollmentRepository repo;
    @Autowired
    private UserManagementClient userClient;

    public String nominatePrimaryUser(String username) {
        // Implementation details
    }

    public String nominateSecondary(String username) {
        // Implementation details
    }
}
----

*Purpose*: Service layer to handle the business logic of enrollment operations.

*Annotations*:
- `@Service`: Indicates that an annotated class is a "Service", originally defined by Domain-Driven Design (DDD) as "an operation offered as an interface that stands alone in the model, with no encapsulated state."

*Methods*:
- `nominatePrimaryUser(String username)`: Business logic to nominate a primary user.
- `nominateSecondary(String username)`: Business logic to nominate a secondary user.

=== EnrollmentApplicationTests

[source,java]
----
@SpringBootTest
public class EnrollmentApplicationTests {
    @Test
    public void contextLoads() {
    }
}
----

*Purpose*: Test class for the EnrollmentApplication.

*Annotations*:
- `@SpringBootTest`: Provides a bridge between Spring Boot test features and JUnit. Whenever we are using Spring Boot in our application, this annotation will be useful to bootstrap the entire container. The test cases will be executed using a mock environment.

== 2. Runtime View Diagrams

=== User Registration Flow

[plantuml, user-registration-sequence, png]
----
@startuml
actor "User" as user
participant "EnrollmentController" as controller
participant "EnrollmentService" as service
participant "EnrollmentRepository" as repo

user -> controller : register(username, details)
controller -> service : registerUser(username, details)
service -> repo : save(new User)
repo -> service : user
service -> controller : user
controller -> user : user
@enduml
----

=== Authentication/Login Flow

[plantuml, authentication-sequence, png]
----
@startuml
actor "User" as user
participant "AuthenticationController" as authController
participant "AuthenticationService" as authService
participant "UserRepository" as userRepo

user -> authController : login(username, password)
authController -> authService : authenticate(username, password)
authService -> userRepo : findByUsername(username)
userRepo -> authService : user
authService -> authController : token
authController -> user : token
@enduml
----

=== JWT Token Validation Flow

[plantuml, jwt-validation-sequence, png]
----
@startuml
actor "User" as user
participant "ResourceController" as resourceController
participant "JWTService" as jwtService

user -> resourceController : request(resource)
resourceController -> jwtService : validateToken(token)
jwtService -> resourceController : isValid
resourceController -> user : response
@enduml
----

== 3. Entity Relationship Diagram

[plantuml, er-diagram, png]
----
@startuml
entity "User" {
    * id : Long
    --
    * username : String
    * password : String
}

entity "Enrollment" {
    * id : Long
    --
    * role : String
    * username : String
    * vin : String
}

User ||--o{ Enrollment
@enduml
----

*User*: Represents the user of the system.
- *id*: Primary key.
- *username*: Username of the user.
- *password*: Password for the user account.

*Enrollment*: Represents an enrollment record.
- *id*: Primary key.
- *role*: Role assigned during the enrollment.
- *username*: Associated username.
- *vin*: Vehicle Identification Number associated with the user.

== 4. Detailed Component Interactions

=== Controller-Service-Repository Interactions

1. **EnrollmentController**:
   - Receives HTTP requests.
   - Delegates business operations to **EnrollmentService**.
   - Returns responses based on the outcomes of the business operations.

2. **EnrollmentService**:
   - Handles business logic.
   - Interacts with **EnrollmentRepository** to persist and retrieve data.

3. **EnrollmentRepository**:
   - Extends `JpaRepository`, providing methods to interact with the database.

=== Data Flow Through Layers

1. **Controller** receives a request from the client.
2. **Controller** calls the appropriate method in the **Service** layer.
3. **Service** performs business logic and interacts with the **Repository**.
4. **Repository** interacts with the database and returns data to the **Service**.
5. **Service** processes the data and returns it to the **Controller**.
6. **Controller** sends the response back to the client.

=== Exception Propagation

1. Exceptions are thrown by the **Repository** or during the execution of business logic in the **Service**.
2. Exceptions are caught and handled in the **Service** layer, where appropriate error messages are generated.
3. **Controller** translates exceptions into HTTP responses with suitable status codes.

=== Transaction Boundaries

1. Transactions are typically started at the **Service** layer using `@Transactional` annotation.
2. This ensures that the related database operations either complete successfully or rollback in case of an error.

This detailed design document should provide developers with a clear understanding of the system's architecture, interactions, and data flow.