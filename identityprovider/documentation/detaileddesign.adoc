= Detailed Design Documentation for Identity Provider Application

This document provides a comprehensive detailed design analysis of the Identity Provider application, focusing on its architecture, components, and interactions. It includes class-by-class analysis, runtime view diagrams, entity relationship diagrams, and detailed component interactions.

== Class-by-Class Analysis

=== IdentityproviderApplication

*Purpose:* Serves as the entry point for the Spring Boot application.

*Methods:*
- `public static void main(String[] args)`: Bootstraps the Spring application.

*Annotations:*
- `@SpringBootApplication`: Marks this class as a Spring Boot application.

=== JwtAuthFilter

*Purpose:* Filter to intercept requests and perform JWT validation.

*Methods:*
- `protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException`: Intercepts HTTP requests to validate JWT tokens.

*Annotations:*
- `@Autowired`: Automatically injects the required beans.
- `@Component`: Marks this class as a Spring component.
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.
- `@Slf4j`: Provides a logger for this class.

*Fields:*
- `userService : UserService`: Service for user-related operations.

=== SecurityConfig

*Purpose:* Configuration for security aspects of the application, such as authentication and authorization.

*Methods:*
- `public AuthenticationManager authenticationManager(final AuthenticationConfiguration authConfig) throws Exception`: Configures the authentication manager.
- `public AuthenticationProvider authenticationProvider()`: Provides a custom authentication provider.
- `public SecurityFilterChain securityFilterChain(final HttpSecurity http) throws Exception`: Defines security filter chain.

*Annotations:*
- `@Autowired`: Injects other components or beans.
- `@Bean`: Indicates that a method produces a bean to be managed by the Spring container.
- `@Configuration`: Indicates that the class has @Bean definition methods.
- `@EnableWebSecurity`: Enables Spring Security's web security support.

*Fields:*
- `jwtAuthFilter : JwtAuthFilter`: JWT authentication filter.
- `userDetailsService : UserDetailsService`: Service to load user-specific data.

=== UserController

*Purpose:* Controller to handle user-related operations such as registration, login, and token refresh.

*Methods:*
- `public ResponseEntity<Object> login(@RequestBody final Users user)`: Handles user login.
- `public ResponseEntity<Void> refreshToken(@RequestBody Users user)`: Handles JWT token refresh.
- `public Users registerUser(@RequestBody final Users user)`: Registers a new user.

*Annotations:*
- `@Autowired`: Injects other components or beans.
- `@PostMapping`: Annotation for mapping HTTP POST requests onto specific handler methods.
- `@RequestBody`: Annotation indicating a method parameter should be bound to the body of the HTTP request.
- `@RequestMapping`: Annotation for mapping web requests onto methods in request-handling classes.
- `@RestController`: Marks the class as a controller where every method returns a domain object instead of a view.

*Fields:*
- `authManager : AuthenticationManager`: Authentication manager for handling authentication.
- `jwtService : JWTService`: Service for JWT operations.
- `userService : UserService`: Service for user-related operations.

=== AuthRequest

*Purpose:* Represents the authentication request containing username and password.

*Methods:* None

*Annotations:*
- `@Data`: Lombok annotation to create all the getters, setters, equals, hash, and toString methods, based on the fields.

*Fields:*
- `password : String`: User's password.
- `username : String`: User's username.

=== AuthResponse

*Purpose:* Represents the authentication response, typically containing a JWT.

*Methods:* None

*Annotations:* None

*Fields:* None

=== UserPrincipal

*Purpose:* Principal object representing a user in Spring Security.

*Methods:*
- Implements various methods from `UserDetails` interface such as `getAuthorities()`, `getPassword()`, `getUsername()`, and checks for account status.

*Annotations:*
- `@Override`: Indicates overriding a method.

*Fields:*
- `user : final Users`: The user entity associated with this principal.

=== Client

*Purpose:* Entity representing a client application that can request tokens.

*Methods:* None

*Annotations:*
- `@Column`: Specifies the mapped column for a persistent property.
- `@Entity`: Specifies that the class is an entity.
- `@GeneratedValue`: Provides for the specification of generation strategies for the values of primary keys.
- `@Getter`: Lombok annotation to generate getters.
- `@Id`: Specifies the primary key.
- `@Setter`: Lombok annotation to generate setters.
- `@Table`: Specifies the primary table for the annotated entity.

*Fields:*
- `clientName : String`: Name of the client.
- `clientSecret : String`: Secret used for client authentication.
- `id : Long`: Primary key.
- `redirectUri : String`: URI to redirect after authentication.

=== Role

*Purpose:* Entity representing a user role.

*Methods:*
- `public Long getId()`: Returns the role ID.
- `public Set<User> getUsers()`: Returns the set of users with this role.
- `public String getName()`: Returns the role name.
- `public void setId(Long id)`: Sets the role ID.
- `public void setName(String name)`: Sets the role name.
- `public void setUsers(Set<User> users)`: Sets the users with this role.

*Annotations:*
- `@Column`: Specifies the mapped column for a persistent property.
- `@Entity`: Specifies that the class is an entity.
- `@GeneratedValue`: Specifies the generation strategy for the primary key.
- `@Id`: Marks the field as a primary key.
- `@ManyToMany`: Defines a many-to-many relationship with another entity.
- `@Table`: Specifies the table that stores the entity.

*Fields:*
- `id : Long`: Primary key.
- `name : String`: Name of the role.
- `users : Set<User>`: Users associated with this role.

=== Token

*Purpose:* Entity representing an authentication or refresh token.

*Methods:* None

*Annotations:*
- `@Column`: Specifies the mapped column for a persistent property.
- `@Entity`: Specifies that the class is an entity.
- `@GeneratedValue`: Specifies the generation strategy for the primary key.
- `@Getter`: Lombok annotation to generate getters.
- `@Id`: Marks the field as a primary key.
- `@JoinColumn`: Specifies a column for joining an entity association.
- `@ManyToOne`: Defines a many-to-one relationship with another entity.
- `@Setter`: Lombok annotation to generate setters.
- `@Table`: Specifies the table that stores the entity.

*Fields:*
- `accessToken : String`: The access token.
- `client : Client`: The client associated with this token.
- `id : Long`: Primary key.
- `refreshToken : String`: The refresh token.
- `user : User`: The user associated with this token.

=== User

*Purpose:* Entity representing a user.

*Methods:* None

*Annotations:*
- `@Column`: Specifies the mapped column for a persistent property.
- `@Data`: Lombok annotation to create all the getters, setters, equals, hash, and toString methods, based on the fields.
- `@Entity`: Specifies that the class is an entity.
- `@GeneratedValue`: Specifies the generation strategy for the primary key.
- `@Getter`: Lombok annotation to generate getters.
- `@Id`: Marks the field as a primary key.
- `@JoinColumn`: Specifies a column for joining an entity association.
- `@JoinTable`: Specifies the table for a join.
- `@ManyToMany`: Defines a many-to-many relationship with another entity.
- `@Setter`: Lombok annotation to generate setters.
- `@Table`: Specifies the table that stores the entity.

*Fields:*
- `email : String`: Email of the user.
- `id : Long`: Primary key.
- `passwordHash : String`: Hashed password of the user.
- `roles : Set<Role>`: Roles associated with the user.
- `username : String`: Username of the user.

=== UserRepository

*Purpose:* Repository for accessing user data.

*Methods:* None

*Annotations:*
- `@Repository`: Indicates that the class is a repository, which encapsulates the logic required to access data sources.

*Fields:* None

=== AuditService

*Purpose:* Service for logging audit events.

*Methods:*
- `public void logEvent(String event)`: Logs an audit event.

*Annotations:*
- `@Service`: Marks the class as a service, which holds business logic.

*Fields:* None

=== EmailService

*Purpose:* Service for sending emails.

*Methods:*
- `public void sendWelcomeEmail(String to)`: Sends a welcome email to the specified recipient.

*Annotations:*
- `@Service`: Marks the class as a service, which holds business logic.

*Fields:*
- `notificationService : final NotificationService`: Service for sending notifications.

=== JWTService

*Purpose:* Service for handling JWT operations such as creation, extraction, validation, and invalidation.

*Methods:*
- `public String extractUsername(String token)`: Extracts the username from the token.
- `public String generateToken(final String username)`: Generates a token for the specified username.
- `public boolean validateToken(String token)`: Validates the specified token.
- `public void invalidateToken(String token)`: Invalidates the specified token.

*Annotations:*
- `@Service`: Marks the class as a service, which holds business logic.
- `@Slf4j`: Provides a logger for this class.

*Fields:*
- `auditService : final AuditService`: Service for logging audit events.
- `secretKey : final Key`: The key used for signing tokens.
- `tokenBlacklistService : final TokenBlacklistService`: Service for managing blacklisted tokens.

=== NotificationService

*Purpose:* Service for sending notifications.

*Methods:*
- `public void notifyUser(String user, String message)`: Sends a notification to the specified user.

*Annotations:*
- `@Service`: Marks the class as a service, which holds business logic.

*Fields:* None

=== TokenBlacklistService

*Purpose:* Service for managing blacklisted tokens.

*Methods:*
- `public void blacklistToken(String token)`: Adds the specified token to the blacklist.

*Annotations:*
- `@Service`: Marks the class as a service, which holds business logic.

*Fields:* None

=== UserService

*Purpose:* Service for user-related operations such as loading user details and registering new users.

*Methods:*
- `public UserDetails loadUserByUsername(final String username) throws UsernameNotFoundException`: Loads user details by username.
- `public Users register(final Users user)`: Registers a new user.

*Annotations:*
- `@Autowired`: Injects other components or beans.
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.
- `@Service`: Marks the class as a service, which holds business logic.

*Fields:*
- `auditService : AuditService`: Service for logging audit events.
- `emailService : EmailService`: Service for sending emails.
- `encoder : BCryptPasswordEncoder`: Encoder for password hashing.
- `userRepository : UserRepository`: Repository for accessing user data.

=== IdentityproviderApplicationTests

*Purpose:* Contains tests for the Identity Provider application.

*Methods:* None

*Annotations:*
- `@SpringBootTest`: Indicates that the class should bootstrap the application for integration tests.
- `@Test`: Indicates that the method is a test method.

*Fields:* None

== Runtime View Diagrams

=== Sequence Diagrams

==== User Registration Flow

[plantuml, user-registration-flow, png]
----
@startuml
actor User
boundary UserController
control UserService
database UserRepository

User -> UserController : register(user)
UserController -> UserService : register(user)
UserService -> UserRepository : save(user)
UserRepository --> UserService : user
UserService --> UserController : user
UserController --> User : user
@enduml
----

==== Authentication/Login Flow

[plantuml, authentication-flow, png]
----
@startuml
actor User
boundary UserController
control UserService
control JWTService

User -> UserController : login(authRequest)
UserController -> UserService : loadUserByUsername(username)
UserService --> UserController : userDetails
UserController -> JWTService : generateToken(username)
JWTService --> UserController : token
UserController --> User : token
@enduml
----

==== JWT Token Validation Flow

[plantuml, jwt-validation-flow, png]
----
@startuml
actor User
boundary JwtAuthFilter
control JWTService

User -> JwtAuthFilter : request(resource)
JwtAuthFilter -> JWTService : validateToken(token)
JWTService --> JwtAuthFilter : isValid
JwtAuthFilter --> User : proceed / error
@enduml
----

==== Business Process Flows

[plantuml, business-process-flow, png]
----
@startuml
actor Client
boundary UserController
control UserService
control JWTService
control AuditService

Client -> UserController : performAction(action)
UserController -> UserService : validateUser(user)
UserService --> UserController : isValid
UserController -> JWTService : checkPermissions(user, action)
JWTService --> UserController : isAllowed
UserController -> AuditService : logEvent("Action performed")
AuditService --> UserController : logged
UserController --> Client : actionResult
@enduml
----

==== Exception Handling Flows

[plantuml, exception-handling-flow, png]
----
@startuml
actor User
boundary UserController
control UserService
database UserRepository

User -> UserController : request(invalidData)
alt valid data
    UserController -> UserService : processData(data)
    UserService -> UserRepository : save(data)
    UserRepository --> UserService : saved
    UserService --> UserController : success
    UserController --> User : response
else invalid data
    UserController --> User : errorResponse
end
@enduml
----

== Entity Relationship Diagram

[plantuml, entity-relationship-diagram, png]
----
@startuml
entity User {
    * id : Long
    * username : String
    * passwordHash : String
    * email : String
    roles : Set<Role>
}

entity Role {
    * id : Long
    * name : String
    users : Set<User>
}

entity Client {
    * id : Long
    * clientName : String
    * clientSecret : String
    * redirectUri : String
}

entity Token {
    * id : Long
    * accessToken : String
    * refreshToken : String
    user : User
    client : Client
}

User "1" -- "many" Role : has >
Role "many" -- "1" User : belongs to <
User "1" -- "many" Token : has >
Token "many" -- "1" User : belongs to <
Client "1" -- "many" Token : has >
Token "many" -- "1" Client : belongs to <
@enduml
----

=== Detailed Description of Entities and Relationships

*User:*
- Represents an individual user of the system.
- Has a many-to-many relationship with the Role entity, indicating the roles assigned to the user.
- Has a one-to-many relationship with the Token entity, indicating the tokens issued to the user.

*Role:*
- Represents a security role within the system.
- Has a many-to-many relationship with the User entity, indicating the users that are assigned this role.

*Client:*
- Represents a client application that can request tokens for accessing resources.
- Has a one-to-many relationship with the Token entity, indicating the tokens issued to the client.

*Token:*
- Represents both access and refresh tokens that are used for securing API access.
- Has a many-to-one relationship with the User entity, linking it to the user who owns the token.
- Has a many-to-one relationship with the Client entity, linking it to the client that the token was issued for.

== Detailed Component Interactions

=== Controller-Service-Repository Interactions

*UserController interacts with UserService for user-related operations.*
- UserController receives HTTP requests and delegates business logic execution to UserService.
- UserService interacts with UserRepository to persist and retrieve user data.

*JWTService is used for token generation and validation.*
- UserController uses JWTService for generating tokens during the login process.
- JwtAuthFilter uses JWTService for validating tokens in incoming requests.

=== Data Flow Through Layers

*Data flows from controllers to services and then to repositories.*
- Controllers receive data from HTTP requests.
- Services process the data, applying business rules.
- Repositories perform data persistence operations.

=== Exception Propagation

*Exceptions are propagated from repositories to services and then to controllers.*
- Repositories throw data access exceptions.
- Services catch these exceptions and may throw business exceptions.
- Controllers catch business exceptions and translate them into HTTP responses.

=== Transaction Boundaries

*Defined at the service layer.*
- Services define transaction boundaries to ensure data integrity.
- Transactions are started before business logic execution and are committed or rolled back depending on the execution outcome.

This detailed design document provides a comprehensive overview of the Identity Provider application, detailing its components, interactions, and data flow, which are crucial for developers involved in maintaining or enhancing the system.