= Identity Provider Detailed Design Documentation

This document provides a comprehensive detailed design for the Identity Provider application, developed using Java Spring Boot. It includes class-by-class analysis, runtime view diagrams, entity relationship diagrams, and detailed component interactions.

== Class-by-Class Analysis

=== IdentityproviderApplication

The `IdentityproviderApplication` class is the entry point of the Spring Boot application. It is annotated with `@SpringBootApplication`, which is a convenience annotation that adds all of the following:

- `@Configuration`: Tags the class as a source of bean definitions for the application context.
- `@EnableAutoConfiguration`: Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings.
- `@ComponentScan`: Tells Spring to look for other components, configurations, and services in the specified package, allowing it to find and register the controllers.

[source,java]
----
public static void main(String[] args) {
    SpringApplication.run(IdentityproviderApplication.class, args);
}
----

=== JwtAuthFilter

`JwtAuthFilter` is a component that intercepts HTTP requests to validate JWT tokens. It extends `OncePerRequestFilter` to ensure a single execution per request dispatch. It is annotated with `@Component` to be automatically detected and registered by Spring's component-scanning mechanism. The `@Slf4j` provides a logger.

[source,java]
----
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
    // Implementation details for JWT validation
}
----

=== SecurityConfig

`SecurityConfig` configures web security for the application. It is marked with `@Configuration` to indicate that it provides bean definitions. `@EnableWebSecurity` enables Spring Securityâ€™s web security support.

[source,java]
----
@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
    return authConfig.getAuthenticationManager();
}

@Bean
public AuthenticationProvider authenticationProvider() {
    // returns an instance of a class that implements AuthenticationProvider
}

@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
        .anyRequest().authenticated()
        .and()
        .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
    return http.build();
}
----

=== UserController

`UserController` handles all user-related operations such as registration, login, and token management. It is annotated with `@RestController`, indicating it's ready for use by Spring MVC to handle web requests. `@RequestMapping("/idp/users")` maps web requests to methods in this controller.

[source,java]
----
@PostMapping("/register")
public User registerUser(@RequestBody final User user) {
    return userService.register(user);
}

@PostMapping("/login")
public ResponseEntity<Object> login(@RequestBody final User user) {
    // Implementation for login
}

@PostMapping("/refreshtoken")
public ResponseEntity<Object> refreshToken(@RequestBody User user) {
    // Implementation for refreshing JWT token
}
----

=== AuthRequest

`AuthRequest` is a simple data transfer object (DTO) that contains user credentials. It is annotated with `@Data` from Lombok to provide boilerplate code like getters, setters, equals, hashcode, and toString methods.

[source,java]
----
private String username;
private String password;
----

=== User

`User` is an entity representing a user in the system. It is annotated with `@Entity` and `@Table(name = "users")` to specify the table in the database. It includes fields like `username`, `passwordHash`, and `roles`.

[source,java]
----
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;

@Column(nullable = false, unique = true)
private String username;

@Column(nullable = false)
private String passwordHash;

@ManyToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
@JoinTable(name = "user_roles",
    joinColumns = @JoinColumn(name = "user_id"),
    inverseJoinColumns = @JoinColumn(name = "role_id"))
private Set<Role> roles;
----

== Runtime View Diagrams

=== User Registration Flow

[plantuml, user-registration-sequence, png]
----
@startuml
actor "User" as user
participant "UserController" as controller
participant "UserService" as service
participant "UserRepository" as repository

user -> controller : register(user)
controller -> service : register(user)
service -> repository : save(user)
repository --> service : user
service --> controller : user
controller --> user : user
@enduml
----

=== Authentication/Login Flow

[plantuml, authentication-sequence, png]
----
@startuml
actor "User" as user
participant "UserController" as controller
participant "UserService" as service
participant "JWTService" as jwt

user -> controller : login(authRequest)
controller -> service : loadUserByUsername(username)
service --> controller : userDetails
controller -> jwt : generateToken(username)
jwt --> controller : token
controller --> user : token
@enduml
----

=== JWT Token Validation Flow

[plantuml, jwt-validation-sequence, png]
----
@startuml
actor "User" as user
participant "JwtAuthFilter" as filter
participant "JWTService" as jwt

user -> filter : request(resource)
filter -> jwt : validateToken(token)
jwt --> filter : isValid
filter --> user : proceed / error
@enduml
----

== Entity Relationship Diagram

[plantuml, er-diagram, png]
----
@startuml
entity "User" {
    * id : Long
    --
    * username : String
    * passwordHash : String
    * roles : Set<Role>
}

entity "Role" {
    * id : Long
    --
    * name : String
    * users : Set<User>
}

entity "Token" {
    * id : Long
    --
    * accessToken : String
    * refreshToken : String
    * user : User
    * client : Client
}

entity "Client" {
    * id : Long
    --
    * clientName : String
    * clientSecret : String
    * redirectUri : String
}

User "1" -- "*" Role
User "1" -- "*" Token
Client "1" -- "*" Token
@enduml
----

== Detailed Component Interactions

=== Controller-Service-Repository Interactions

- `UserController` interacts with `UserService` to handle user registration and authentication.
- `UserService` uses `UserRepository` to interact with the database for CRUD operations on the `User` entity.
- `UserService` also interacts with `JWTService` for token generation and validation.

=== Data Flow Through Layers

- Data flows from the controllers to services where business logic is applied. Then, data is either stored or retrieved from the database through repositories.
- Responses are sent back through the service to the controller and finally to the client.

=== Exception Propagation

- Exceptions are thrown from the repositories or services when data constraints are violated or data is not found.
- These exceptions are caught in the controllers where appropriate HTTP responses are generated.

=== Transaction Boundaries

- Transactions are typically started at the service layer to ensure data integrity and are committed when the business process completes successfully or rolled back if an exception occurs.

This detailed design document should provide developers with a clear understanding of the application's architecture, data flow, and interactions.