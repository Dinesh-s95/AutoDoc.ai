= Identity Provider Application Detailed Design Document

The Identity Provider Application is a Java-based application utilizing Spring Boot for managing user authentication and authorization through JWT (JSON Web Tokens). This document provides a detailed design description of the application, including class-by-class analysis, runtime view diagrams, entity relationship diagrams, and detailed component interactions.

== 1. Class-by-Class Analysis

=== 1.1 IdentityproviderApplication

*Purpose*: Serves as the entry point for the Spring Boot application.

*Annotations*:
- `@SpringBootApplication`: Indicates a configuration class that declares one or more `@Bean` methods and also triggers auto-configuration and component scanning.

*Methods*:
- `public static void main(String[] args)`: The main method which Spring Boot uses to start the application.

=== 1.2 JwtAuthFilter

*Purpose*: Intercepts HTTP requests to check for the presence of a JWT in the header and validates it.

*Annotations*:
- `@Autowired`: Marks a dependency to be injected by Spring's dependency injection facilities.
- `@Component`: Indicates that the class is a Spring-managed component.
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.
- `@Slf4j`: Embedded support for logging via the Slf4j API.

*Methods*:
- `protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException`: Filters incoming requests and checks for JWT in the Authorization header.

*Fields*:
- `userService : UserService`: Dependency to manage user-related operations.

=== 1.3 SecurityConfig

*Purpose*: Configuration for security aspects of the application, such as authentication and authorization mechanisms.

*Annotations*:
- `@Autowired`: Used for dependency injection.
- `@Bean`: Indicates that a method produces a bean to be managed by the Spring container.
- `@Configuration`: Indicates that the class has `@Bean` definition methods.
- `@EnableWebSecurity`: Adds Spring Security configuration.

*Methods*:
- `public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception`: Defines the application's authentication manager.
- `public AuthenticationProvider authenticationProvider()`: Defines a custom authentication provider.
- `public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception`: Configures the security filter chain.

*Fields*:
- `jwtAuthFilter : JwtAuthFilter`: The JWT authentication filter.
- `userDetailsService : UserDetailsService`: Service to load user-specific data.

=== 1.4 UserController

*Purpose*: Controller to handle user-related operations such as registration and login.

*Annotations*:
- `@Autowired`: Used for dependency injection.
- `@GetMapping`, `@PostMapping`: Annotations for mapping HTTP GET and POST requests on specific handler methods.
- `@RequestBody`: Annotation indicating a method parameter should be bound to the body of the HTTP request.
- `@RequestMapping`: Annotation for mapping web requests onto methods in request-handling classes.
- `@RestController`: Indicates that the data returned by each method will be written straight into the response body instead of rendering a template.

*Methods*:
- `public String greet()`: Returns a greeting message.
- `public ResponseEntity<Object> login(@RequestBody final Users user)`: Handles the login process.
- `public Users registerUser(@RequestBody final Users user)`: Handles the user registration process.

*Fields*:
- `authManager : AuthenticationManager`: Manages authentication processes.
- `jwtService : JWTService`: Service for handling JWT operations.
- `userService : UserService`: Service for user management operations.

=== 1.5 Users

*Purpose*: Entity representing a user in the system.

*Annotations*:
- `@Data`: Lombok annotation to create all the getters, setters, equals, hash, and toString methods, based on the fields.
- `@Entity`: Specifies that the class is an entity and is mapped to a database table.
- `@GeneratedValue`: Specifies the generation strategy for the primary keys.
- `@Id`: Specifies the primary key of an entity.
- `@Getter`, `@Setter`: Lombok annotations to generate getters and setters.

*Methods*:
- `public String getPassword()`: Returns the user's password.
- `public String getUsername()`: Returns the user's username.

*Fields*:
- `password : String`: The user's password.
- `userId : Long`: The unique ID of the user.
- `username : String`: The user's username.

=== 1.6 UserRepository

*Purpose*: Repository interface for CRUD operations on the Users entity.

*Annotations*:
- `@Repository`: Indicates that the class is a repository, which encapsulates the storage, retrieval, and search behavior typically from a relational database.

=== 1.7 JWTService

*Purpose*: Service to handle JWT creation and validation.

*Annotations*:
- `@Service`: Indicates that the class is a service provider.
- `@Slf4j`: Embedded support for logging via the Slf4j API.

*Methods*:
- `public String extractUsername(String token)`: Extracts the username from the JWT.
- `public String generateToken(final String username)`: Generates a JWT for a given username.
- `public boolean validateToken(String token)`: Validates a given JWT.

*Fields*:
- `secretKey : final Key`: The secret key used for signing the JWT.

=== 1.8 UserService

*Purpose*: Service to manage user data and interactions.

*Annotations*:
- `@Autowired`: Used for dependency injection.
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.
- `@Service`: Indicates that the class is a service provider.

*Methods*:
- `public UserDetails loadUserByUsername(final String username) throws UsernameNotFoundException`: Loads user details by username.
- `public Users register(final Users user)`: Registers a new user.

*Fields*:
- `encoder : BCryptPasswordEncoder`: Password encoder for encoding passwords.
- `userRepository : UserRepository`: Repository for user data access.

== 2. Runtime View Diagrams

=== 2.1 User Registration Flow

[plantuml, user-registration-sequence, png]
----
@startuml
actor "User" as user
participant "UserController" as controller
participant "UserService" as service
participant "UserRepository" as repository

user -> controller : register(user)
controller -> service : register(user)
service -> repository : save(user)
repository -> service : user
service -> controller : user
controller -> user : user
@enduml
----

=== 2.2 Authentication/Login Flow

[plantuml, authentication-sequence, png]
----
@startuml
actor "User" as user
participant "UserController" as controller
participant "AuthenticationManager" as authManager
participant "JWTService" as jwtService

user -> controller : login(credentials)
controller -> authManager : authenticate(credentials)
authManager -> controller : authentication
controller -> jwtService : generateToken(authentication)
jwtService -> controller : token
controller -> user : token
@enduml
----

=== 2.3 JWT Token Validation Flow

[plantuml, jwt-validation-sequence, png]
----
@startuml
actor "User" as user
participant "JwtAuthFilter" as filter
participant "JWTService" as jwtService

user -> filter : request(resource)
filter -> jwtService : validateToken(token)
jwtService -> filter : isValid
filter -> user : proceed / error
@enduml
----

== 3. Entity Relationship Diagram

[plantuml, entity-relationship-diagram, png]
----
@startuml
entity "Users" {
  * userId : Long
  --
  * username : String
  * password : String
}

@enduml
----

== 4. Detailed Component Interactions

=== 4.1 Controller-Service-Repository Interactions

- **UserController** interacts with **UserService** to handle user registration and login.
- **UserService** uses **UserRepository** for database operations like saving a new user or fetching user details.

=== 4.2 Data Flow Through Layers

- Data flows from the controller to the service layer where business logic is applied, then to the repository layer for database operations, and back to the user.

=== 4.3 Exception Propagation

- Exceptions in the repository layer are propagated to the service layer, which in turn can propagate them to the controller layer. The controller handles these exceptions and sends appropriate HTTP responses.

=== 4.4 Transaction Boundaries

- Transactions are typically started at the service layer to encompass business operations that involve multiple steps which should either completely succeed or fail together.

This detailed design document provides a comprehensive overview of the Identity Provider Application, ensuring developers have a clear understanding of the application's architecture and interactions.