= Detailed Design Documentation for Identity Provider Application

This document provides a comprehensive detailed design overview of the Identity Provider Application, focusing on the Java Spring Boot implementation. It includes class-by-class analysis, runtime view diagrams with sequence diagrams, entity relationship diagrams, and detailed component interactions.

== Class-by-Class Analysis

=== IdentityproviderApplication

*Purpose*: Serves as the entry point for the Spring Boot application.

*Annotations*:
- `@SpringBootApplication`: Indicates a configuration class that declares one or more `@Bean` methods and also triggers auto-configuration and component scanning.

*Methods*:
- `public static void main(String[] args)`: The main method that uses Spring Boot’s `SpringApplication.run()` method to launch the application.

=== JwtAuthFilter

*Purpose*: Filter that intercepts the HTTP requests to validate JWT tokens.

*Annotations*:
- `@Autowired`: Marks a dependency to be injected by Spring’s dependency injection facilities.
- `@Component`: Indicates that the class is a Spring-managed component.
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.
- `@Slf4j`: Lombok annotation to provide a logger.

*Methods*:
- `protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException`: Filters incoming requests and checks for valid JWT tokens.

*Fields*:
- `userService : UserService`: Dependency to interact with user data.

=== SecurityConfig

*Purpose*: Configuration class for security settings.

*Annotations*:
- `@Autowired`: Marks a dependency to be injected.
- `@Bean`: Indicates that a method produces a bean to be managed by the Spring container.
- `@Configuration`: Indicates that the class has `@Bean` definition methods.
- `@EnableWebSecurity`: Enables Spring Security’s web security support.

*Methods*:
- `public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception`: Defines the authentication manager bean.
- `public AuthenticationProvider authenticationProvider()`: Defines the authentication provider bean.
- `public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception`: Configures the security filter chain.

*Fields*:
- `jwtAuthFilter : JwtAuthFilter`: JWT authentication filter.
- `userDetailsService : UserDetailsService`: Service to load user-specific data.

=== UserController

*Purpose*: Controller to handle user-related operations such as registration, login, and token refresh.

*Annotations*:
- `@Autowired`: Marks a dependency to be injected.
- `@PostMapping`: Annotation for mapping HTTP POST requests onto specific handler methods.
- `@RequestBody`: Indicates a method parameter should be bound to the body of the web request.
- `@RequestMapping`: Annotation for mapping web requests onto methods in request-handling classes.
- `@RestController`: Indicates that the data returned by each method will be written straight into the response body instead of rendering a template.

*Methods*:
- `public ResponseEntity<Object> login(@RequestBody final Users user)`: Handles the login request.
- `public ResponseEntity<Void> refreshToken()`: Handles the token refresh request.
- `public Users registerUser(@RequestBody final Users user)`: Handles the user registration request.

*Fields*:
- `authManager : AuthenticationManager`: Authentication manager for handling authentication.
- `jwtService : JWTService`: Service for handling JWT operations.
- `userService : UserService`: Service for user-related operations.

=== AuthRequest

*Purpose*: Data transfer object for authentication request.

*Annotations*:
- `@Data`: Lombok annotation to generate getters, setters, toString, equals, and hashCode methods.

*Fields*:
- `password : String`: User's password.
- `username : String`: User's username.

=== AuthResponse

*Purpose*: Data transfer object for authentication response.

=== UserPrincipal

*Purpose*: Principal object representing a user.

*Annotations*:
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.

*Methods*:
- `public Collection<? extends GrantedAuthority> getAuthorities()`: Returns the authorities granted to the user.
- `public String getPassword()`: Returns the user's hashed password.
- `public String getUsername()`: Returns the username used to authenticate the user.
- `public boolean isAccountNonExpired()`: Indicates whether the user's account has expired.
- `public boolean isAccountNonLocked()`: Indicates whether the user is locked or unlocked.
- `public boolean isCredentialsNonExpired()`: Indicates whether the user's credentials (password) has expired.
- `public boolean isEnabled()`: Indicates whether the user is enabled or disabled.

*Fields*:
- `user : final Users`: The user entity associated with this principal.

=== Client

*Purpose*: Entity representing a client application.

*Annotations*:
- `@Column`: Specifies the mapped column for a persistent property.
- `@Entity`: Specifies that the class is an entity.
- `@GeneratedValue`: Provides for the specification of generation strategies for the values of primary keys.
- `@Getter`: Lombok annotation to generate the getter method for the fields.
- `@Id`: Specifies the primary key of an entity.
- `@Setter`: Lombok annotation to generate the setter method for the fields.
- `@Table`: Specifies the primary table for the annotated entity.

*Fields*:
- `clientName : String`: Name of the client.
- `clientSecret : String`: Secret key for the client.
- `id : Long`: ID of the client.
- `redirectUri : String`: URI to redirect after authentication.

=== Role

*Purpose*: Entity representing a user role.

*Annotations*:
- `@Column`: Specifies the mapped column for a persistent property.
- `@Entity`: Specifies that the class is an entity.
- `@GeneratedValue`: Provides for the specification of generation strategies for the values of primary keys.
- `@Id`: Specifies the primary key of an entity.
- `@ManyToMany`: Defines a many-to-many relationship between the join tables.
- `@Table`: Specifies the primary table for the annotated entity.

*Methods*:
- `public Long getId()`: Returns the role ID.
- `public Set<User> getUsers()`: Returns the set of users with this role.
- `public String getName()`: Returns the name of the role.
- `public void setId(Long id)`: Sets the role ID.
- `public void setName(String name)`: Sets the name of the role.
- `public void setUsers(Set<User> users)`: Sets the users with this role.

*Fields*:
- `id : Long`: ID of the role.
- `name : String`: Name of the role.
- `users : Set<User>`: Users that have this role.

=== Token

*Purpose*: Entity representing an authentication token.

*Annotations*:
- `@Column`: Specifies the mapped column for a persistent property.
- `@Entity`: Specifies that the class is an entity.
- `@GeneratedValue`: Provides for the specification of generation strategies for the values of primary keys.
- `@Getter`: Lombok annotation to generate the getter method for the fields.
- `@Id`: Specifies the primary key of an entity.
- `@JoinColumn`: Specifies a column for joining an entity association or element collection.
- `@ManyToOne`: Defines a many-to-one association to another entity.
- `@Setter`: Lombok annotation to generate the setter method for the fields.
- `@Table`: Specifies the primary table for the annotated entity.

*Fields*:
- `accessToken : String`: Access token string.
- `client : Client`: The client associated with this token.
- `id : Long`: ID of the token.
- `refreshToken : String`: Refresh token string.
- `user : User`: The user associated with this token.

=== User

*Purpose*: Entity representing a user.

*Annotations*:
- `@Column`: Specifies the mapped column for a persistent property.
- `@Data`: Lombok annotation to generate getters, setters, toString, equals, and hashCode methods.
- `@Entity`: Specifies that the class is an entity.
- `@GeneratedValue`: Provides for the specification of generation strategies for the values of primary keys.
- `@Getter`: Lombok annotation to generate the getter method for the fields.
- `@Id`: Specifies the primary key of an entity.
- `@JoinColumn`: Specifies a column for joining an entity association or element collection.
- `@JoinTable`: Specifies the table that is used for the mapping of associations.
- `@ManyToMany`: Defines a many-to-many relationship between the join tables.
- `@Setter`: Lombok annotation to generate the setter method for the fields.
- `@Table`: Specifies the primary table for the annotated entity.

*Fields*:
- `email : String`: Email of the user.
- `id : Long`: ID of the user.
- `passwordHash : String`: Hashed password of the user.
- `roles : Set<Role>`: Roles assigned to the user.
- `username : String`: Username of the user.

=== UserRepository

*Purpose*: Repository interface for CRUD operations on the `User` entity.

*Annotations*:
- `@Repository`: Indicates that the class is a repository, which encapsulates the storage, retrieval, and search behavior typically from a relational database.

=== AuditService

*Purpose*: Service for logging audit events.

*Annotations*:
- `@Service`: Indicates that the class is a service, which holds business logic.

*Methods*:
- `public void logEvent(String event)`: Logs an audit event.

=== EmailService

*Purpose*: Service for sending emails.

*Annotations*:
- `@Service`: Indicates that the class is a service.

*Methods*:
- `public void sendWelcomeEmail(String to)`: Sends a welcome email to the specified recipient.

*Fields*:
- `notificationService : final NotificationService`: Service for sending notifications.

=== JWTService

*Purpose*: Service for handling JWT operations.

*Annotations*:
- `@Service`: Indicates that the class is a service.
- `@Slf4j`: Lombok annotation to provide a logger.

*Methods*:
- `public String extractUsername(String token)`: Extracts the username from the given token.
- `public String generateToken(final String username)`: Generates a token for the given username.
- `public boolean validateToken(String token)`: Validates the given token.
- `public void invalidateToken(String token)`: Invalidates the given token.

*Fields*:
- `auditService : final AuditService`: Service for logging audit events.
- `secretKey : final Key`: The secret key used for signing tokens.
- `tokenBlacklistService : final TokenBlacklistService`: Service for blacklisting tokens.

=== NotificationService

*Purpose*: Service for sending notifications.

*Annotations*:
- `@Service`: Indicates that the class is a service.

*Methods*:
- `public void notifyUser(String user, String message)`: Sends a notification to the specified user.

=== TokenBlacklistService

*Purpose*: Service for blacklisting tokens.

*Annotations*:
- `@Service`: Indicates that the class is a service.

*Methods*:
- `public void blacklistToken(String token)`: Blacklists the specified token.

=== UserService

*Purpose*: Service for user-related operations.

*Annotations*:
- `@Autowired`: Marks a dependency to be injected.
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.
- `@Service`: Indicates that the class is a service.

*Methods*:
- `public UserDetails loadUserByUsername(final String username) throws UsernameNotFoundException`: Loads the user details by username.
- `public Users register(final Users user)`: Registers a new user.

*Fields*:
- `auditService : AuditService`: Service for logging audit events.
- `emailService : EmailService`: Service for sending emails.
- `encoder : BCryptPasswordEncoder`: Encoder for hashing passwords.
- `userRepository : UserRepository`: Repository for CRUD operations on the `User` entity.

=== IdentityproviderApplicationTests

*Purpose*: Class for testing the Identity Provider Application.

*Annotations*:
- `@SpringBootTest`: Indicates that the class should bootstrap with Spring Boot’s support.
- `@Test`: Indicates that the method is a test method.

== Runtime View Diagrams

=== User Registration Flow

[plantuml, user-registration-flow, png]
----
@startuml
actor User
entity UserController
entity UserService
database UserRepository

User -> UserController : register(user)
UserController -> UserService : register(user)
UserService -> UserRepository : save(user)
UserRepository --> UserService : user
UserService --> UserController : user
UserController --> User : user
@enduml
----

=== Authentication/Login Flow

[plantuml, authentication-login-flow, png]
----
@startuml
actor User
entity UserController
entity UserService
entity JWTService

User -> UserController : login(authRequest)
UserController -> UserService : loadUserByUsername(username)
UserService --> UserController : userDetails
UserController -> JWTService : generateToken(userDetails)
JWTService --> UserController : token
UserController --> User : token
@enduml
----

=== JWT Token Validation Flow

[plantuml, jwt-token-validation-flow, png]
----
@startuml
actor User
entity JwtAuthFilter
entity JWTService

User -> JwtAuthFilter : request(resource)
JwtAuthFilter -> JWTService : validateToken(token)
JWTService --> JwtAuthFilter : isValid
JwtAuthFilter --> User : proceed / error
@enduml
----

=== Business Process Flows

[plantuml, business-process-flow, png]
----
@startuml
actor User
entity UserController
entity UserService
entity EmailService

User -> UserController : register(user)
UserController -> UserService : register(user)
UserService -> EmailService : sendWelcomeEmail(user.email)
EmailService --> UserService : emailSent
UserService --> UserController : user
UserController --> User : user
@enduml
----

=== Exception Handling Flows

[plantuml, exception-handling-flow, png]
----
@startuml
actor User
entity UserController
entity UserService

User -> UserController : register(user)
alt valid user
  UserController -> UserService : register(user)
  UserService --> UserController : user
  UserController --> User : user
else invalid user
  UserController --> User : error
end
@enduml
----

== Entity Relationship Diagram

[plantuml, entity-relationship-diagram, png]
----
@startuml
entity User {
  * id : Long
  --
  * username : String
  * email : String
  * passwordHash : String
  --
  * roles : Set<Role>
}

entity Role {
  * id : Long
  --
  * name : String
  --
  * users : Set<User>
}

entity Client {
  * id : Long
  --
  * clientName : String
  * clientSecret : String
  * redirectUri : String
}

entity Token {
  * id : Long
  --
  * accessToken : String
  * refreshToken : String
  --
  * user : User
  * client : Client
}

User "1" -- "0..*" Role : has >
Role "0..*" -- "1" User : belongs to <
User "1" -- "0..*" Token : has >
Token "0..1" -- "1" User : belongs to <
Client "1" -- "0..*" Token : has >
Token "0..1" -- "1" Client : belongs to <
@enduml
----

*User*: Represents an individual user with fields for identification, contact, and authentication.

*Role*: Represents the security roles assigned to users.

*Client*: Represents an application that can request tokens.

*Token*: Represents an authentication token that links a user to the client that requested it.

*Relationships*:
- A user can have multiple roles.
- A role can belong to multiple users.
- A user can have multiple tokens.
- A token is linked to one user and one client.
- A client can have multiple tokens.

== Detailed Component Interactions

=== Controller-Service-Repository Interactions

*UserController* interacts with *UserService* to handle data related to users. *UserService* then interacts with *UserRepository* to perform database operations.

=== Data Flow Through Layers

Data flows from the controllers to services and then to repositories. Data is returned back through the layers enriched or transformed as needed.

=== Exception Propagation

Exceptions are thrown by repositories, caught by services, and handled or logged by controllers. Services may also throw custom exceptions that are handled by controllers.

=== Transaction Boundaries

Transactions are typically started at the service layer. This ensures that all operations performed within a single service method are completed successfully before the transaction is committed, or rolled back in case of an error.

This detailed design document provides a thorough overview of the Identity Provider Application, ensuring that developers have a clear understanding of the application's architecture and flow.