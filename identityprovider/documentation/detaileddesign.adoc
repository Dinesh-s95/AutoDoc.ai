= Detailed Design Document: Identity Provider Application

This document provides a comprehensive detailed design analysis of the Identity Provider application implemented using Java Spring Boot. It includes class-by-class analysis, runtime view diagrams, entity relationship diagrams, and detailed component interactions.

== Class-by-Class Analysis

Each class in the application serves a specific role within the system, from handling security configurations to managing user data and processing authentication requests.

=== IdentityproviderApplication

[source,java]
----
@SpringBootApplication
public class IdentityproviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(IdentityproviderApplication.class, args);
    }
}
----

*Purpose*: Serves as the entry point for the Spring Boot application.
*Annotations*:
- `@SpringBootApplication`: Serves as a convenience annotation that adds all of the following:
  - `@Configuration`: Tags the class as a source of bean definitions for the application context.
  - `@EnableAutoConfiguration`: Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings.
  - `@ComponentScan`: Tells Spring to look for other components, configurations, and services in the specified package, allowing it to find and register the controllers.

=== JwtAuthFilter

[source,java]
----
@Component
@Slf4j
public class JwtAuthFilter extends OncePerRequestFilter {
    @Autowired
    private UserService userService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // Implementation details...
    }
}
----

*Purpose*: Intercepts HTTP requests to validate JWT tokens.
*Methods*:
- `doFilterInternal()`: Extracts and validates the JWT token from the HTTP request headers.
*Annotations*:
- `@Component`: Indicates that the class is a Spring component.
- `@Slf4j`: Provides a logger for the class to log messages.
- `@Autowired`: Automatically injects the required `UserService` dependency.

=== SecurityConfig

[source,java]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Autowired
    private JwtAuthFilter jwtAuthFilter;
    @Autowired
    private UserDetailsService userDetailsService;

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        // Implementation details...
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // Implementation details...
    }
}
----

*Purpose*: Configures security settings for the application, including custom authentication and authorization mechanisms.
*Methods*:
- `authenticationManager()`: Provides the authentication manager bean.
- `authenticationProvider()`: Configures a custom authentication provider.
- `securityFilterChain()`: Defines security rules and stateless session management.
*Annotations*:
- `@Configuration`: Indicates that the class is used for Spring configuration.
- `@EnableWebSecurity`: Enables Spring Security's web security support and provides the Spring MVC integration.
- `@Bean`: Indicates that a method produces a bean to be managed by the Spring container.

=== UserController

[source,java]
----
@RestController
@RequestMapping("/idp/users")
public class UserController {
    @Autowired
    private AuthenticationManager authManager;
    @Autowired
    private JWTService jwtService;
    @Autowired
    private UserService userService;

    @PostMapping("/login")
    public ResponseEntity<Object> login(@RequestBody final Users user) {
        // Implementation details...
    }

    @PostMapping("/register")
    public Users registerUser(@RequestBody final Users user) {
        // Implementation details...
    }
}
----

*Purpose*: Handles all user-related operations such as registration and login.
*Methods*:
- `login()`: Authenticates a user and returns a JWT if successful.
- `registerUser()`: Registers a new user in the system.
*Annotations*:
- `@RestController`: Marks the class as a controller where every method returns a domain object instead of a view.
- `@RequestMapping`: Maps HTTP requests to handler methods of MVC and REST controllers.
- `@PostMapping`: Marks a method to support HTTP POST requests, mapping specific requests to specific methods.
- `@RequestBody`: Indicates a method parameter should be bound to the body of the HTTP request.
- `@Autowired`: Injects the necessary beans automatically.

=== Users

[source,java]
----
@Entity
@Data
public class Users {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId;
    private String username;
    private String password;

    public String getPassword() {
        return this.password;
    }

    public String getUsername() {
        return this.username;
    }
}
----

*Purpose*: Represents the user entity in the database.
*Methods*:
- `getPassword()`: Returns the user's hashed password.
- `getUsername()`: Returns the username.
*Annotations*:
- `@Entity`: Specifies that the class is an entity and is mapped to a database table.
- `@Data`: Lombok annotation to create all the getters, setters, equals, hash, and toString methods, among others.
- `@Id`: Specifies the primary key of an entity.
- `@GeneratedValue`: Provides for the specification of generation strategies for the values of primary keys.

=== UserRepository

[source,java]
----
@Repository
public interface UserRepository extends JpaRepository<Users, Long> {
}
----

*Purpose*: Interface for CRUD operations on the `Users` entity.
*Annotations*:
- `@Repository`: Indicates that the interface is a repository and translates exceptions into Spring's data access exception hierarchy.

=== JWTService

[source,java]
----
@Service
@Slf4j
public class JWTService {
    private final Key secretKey;

    public String extractUsername(String token) {
        // Implementation details...
    }

    public String generateToken(final String username) {
        // Implementation details...
    }

    public boolean validateToken(String token) {
        // Implementation details...
    }
}
----

*Purpose*: Manages JWT creation and validation.
*Methods*:
- `extractUsername()`: Extracts username from the JWT token.
- `generateToken()`: Generates a JWT token for a given username.
- `validateToken()`: Validates a JWT token.
*Annotations*:
- `@Service`: Marks the class as a service provider, which holds business logic.
- `@Slf4j`: Provides logging capability for the class.

=== UserService

[source,java]
----
@Service
public class UserService implements UserDetailsService {
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private BCryptPasswordEncoder encoder;

    @Override
    public UserDetails loadUserByUsername(final String username) throws UsernameNotFoundException {
        // Implementation details...
    }

    public Users register(final Users user) {
        // Implementation details...
    }
}
----

*Purpose*: Manages user-related business logic and interacts with the `UserRepository`.
*Methods*:
- `loadUserByUsername()`: Loads a user by username and is used by Spring Security during the authentication process.
- `register()`: Registers a new user with encoded password.
*Annotations*:
- `@Service`: Indicates that the class is a service component.
- `@Autowired`: Automatically injects the required dependencies.
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.

=== IdentityproviderApplicationTests

[source,java]
----
@SpringBootTest
public class IdentityproviderApplicationTests {

    @Test
    public void contextLoads() {
    }
}
----

*Purpose*: Provides basic integration tests to ensure the Spring context loads correctly.
*Annotations*:
- `@SpringBootTest`: Provides support for loading a complete application context in tests.
- `@Test`: Marks a method to be run as a test case.

== Runtime View Diagrams

The following sequence diagrams illustrate key business flows within the application.

=== User Registration Flow

[source,plantuml]
----
@startuml
actor "User" as user
participant "UserController" as controller
participant "UserService" as service
participant "UserRepository" as repo

user -> controller : register(user)
controller -> service : register(user)
service -> repo : save(user)
repo -> service : user
service -> controller : user
controller -> user : user
@enduml
----

=== Authentication/Login Flow

[source,plantuml]
----
@startuml
actor "User" as user
participant "UserController" as controller
participant "AuthenticationManager" as authManager
participant "JWTService" as jwtService

user -> controller : login(user)
controller -> authManager : authenticate(user)
authManager -> controller : authentication
controller -> jwtService : generateToken(user.username)
jwtService -> controller : token
controller -> user : token
@enduml
----

=== JWT Token Validation Flow

[source,plantuml]
----
@startuml
actor "User" as user
participant "JwtAuthFilter" as filter
participant "JWTService" as jwtService

user -> filter : request(resource)
filter -> jwtService : validateToken(token)
jwtService -> filter : isValid
filter -> user : proceed / error
@enduml
----

=== Key Business Process Flow

[source,plantuml]
----
@startuml
actor "User" as user
participant "UserController" as controller
participant "UserService" as service
participant "UserRepository" as repo
participant "JWTService" as jwtService

user -> controller : login(user)
controller -> service : loadUserByUsername(user.username)
service -> repo : findByUsername(user.username)
repo -> service : user
service -> controller : userDetails
controller -> jwtService : generateToken(user.username)
jwtService -> controller : token
controller -> user : token
@enduml
----

=== Exception Handling Flow

[source,plantuml]
----
@startuml
actor "User" as user
participant "UserController" as controller
participant "UserService" as service
participant "Exception" as exception

user -> controller : action()
controller -> service : process()
service -> exception : throw(new Exception)
exception -> controller : exception
controller -> user : errorResponse
@enduml
----

== Entity Relationship Diagram

The following diagram illustrates the entity relationships within the application.

[source,plantuml]
----
@startuml
entity "Users" {
    * userId : Long <<generated>>
    --
    * username : String
    * password : String
}

@enduml
----

== Detailed Component Interactions

=== Controller-Service-Repository Interactions

The interactions between the controller, service, and repository layers are crucial for the data flow through the application. Here is how these components interact:

- The `UserController` handles incoming HTTP requests and delegates business processing to the `UserService`.
- The `UserService` performs the business logic and interacts with the `UserRepository` to retrieve or persist data.
- The `UserRepository` abstracts the database access and provides CRUD operations on the `Users` entity.

=== Data Flow Through Layers

Data flows from the controllers to services and then to repositories (or vice versa), encapsulating business logic and database access, respectively. This separation ensures that each layer has a single responsibility and can be independently maintained and tested.

=== Exception Propagation

Exceptions are thrown from the repositories or services and are caught in the controllers where appropriate error responses are generated. This allows the application to handle failures gracefully and provide meaningful error messages to the clients.

=== Transaction Boundaries

Spring manages transactions at the service layer, ensuring that database operations are completed successfully before committing the transaction. If an exception occurs, the transaction is rolled back to maintain data integrity.

This detailed design document provides a thorough overview of the Identity Provider application, ensuring that developers have a clear understanding of its implementation and architecture.