= Identity Provider Detailed Design Documentation

== Introduction

This document provides a detailed design description of the Identity Provider system implemented using Java Spring Boot. It covers class-by-class analysis, runtime view diagrams.

== Class-by-Class Analysis

=== IdentityproviderApplication

[source,java]
----
@SpringBootApplication
public class IdentityproviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(IdentityproviderApplication.class, args);
    }
}
----

*Purpose*: Entry point of the Spring Boot application.

*Methods*:
- `main(String[] args)`: Launches the Spring Boot application.

*Annotations*:
- `@SpringBootApplication`: Marks this class as a Spring Boot application.

=== JwtAuthFilter

[source,java]
----
@Component
@Slf4j
public class JwtAuthFilter extends OncePerRequestFilter {
    @Autowired
    private UserService userService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // Implementation details
    }
}
----

*Purpose*: Filter that intercepts requests to validate JWT tokens.

*Methods*:
- `doFilterInternal(...)`: Validates the JWT token present in the request headers.

*Annotations*:
- `@Component`: Marks this class as a Spring-managed component.
- `@Slf4j`: Provides logging capability.

*Fields*:
- `userService`: Injected service for user-related operations.

=== SecurityConfig

[source,java]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private JwtAuthFilter jwtAuthFilter;

    @Autowired
    private UserDetailsService userDetailsService;

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        // Implementation details
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // Implementation details
    }
}
----

*Purpose*: Configuration for security aspects of the application.

*Methods*:
- `authenticationManager(...)`: Provides the authentication manager.
- `authenticationProvider()`: Provides the authentication provider.
- `securityFilterChain(...)`: Configures the security filter chain.

*Annotations*:
- `@Configuration`: Marks this class as a configuration class.
- `@EnableWebSecurity`: Enables Spring Security's web security support.

*Fields*:
- `jwtAuthFilter`: JWT authentication filter.
- `userDetailsService`: Service to load user-specific data.

=== UserController

[source,java]
----
@RestController
@RequestMapping("/idp/users")
public class UserController {

    @Autowired
    private AuthenticationManager authManager;

    @Autowired
    private JWTService jwtService;

    @Autowired
    private UserService userService;

    @PostMapping("/register")
    public Users registerUser(@RequestBody final Users user) {
        return userService.register(user);
    }

    @PostMapping("/login")
    public ResponseEntity<Object> login(@RequestBody final Users user) {
        // Implementation details
    }

    @PostMapping("/refreshtoken")
    public ResponseEntity<Object> refreshToken() {
        // Implementation details
    }
}
----

*Purpose*: Controller to handle user-related operations such as registration and login.

*Methods*:
- `registerUser(...)`: Registers a new user.
- `login(...)`: Authenticates a user and returns a JWT.
- `refreshToken()`: Provides a new JWT using a refresh token.

*Annotations*:
- `@RestController`: Marks this class as a controller where every method returns a domain object instead of a view.
- `@RequestMapping`: Maps web requests onto methods in request-handling classes.
- `@PostMapping`: Annotation for mapping HTTP POST requests onto specific handler methods.

*Fields*:
- `authManager`: Authentication manager for handling authentication.
- `jwtService`: Service for JWT operations.
- `userService`: Service for user-related operations.

=== AuthRequest

[source,java]
----
@Data
public class AuthRequest {
    private String username;
    private String password;
}
----

*Purpose*: Data transfer object for authentication requests.

*Annotations*:
- `@Data`: Lombok annotation to create getters, setters, `toString`, `equals`, and `hashCode` methods.

*Fields*:
- `username`: Username of the user.
- `password`: Password of the user.

=== AuthResponse

[source,java]
----
public class AuthResponse {
    private String jwt;
}
----

*Purpose*: Data transfer object for authentication responses.

*Fields*:
- `jwt`: JWT token issued upon successful authentication.

=== UserPrincipal

[source,java]
----
public class UserPrincipal implements UserDetails {
    private final Users user;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        // Implementation details
    }

    @Override
    public String getPassword() {
        return user.getPasswordHash();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}
----

*Purpose*: Principal object representing a user.

*Methods*:
- `getAuthorities()`: Returns the authorities granted to the user.
- `getPassword()`: Returns the password used to authenticate the user.
- `getUsername()`: Returns the username used to authenticate the user.
- `isAccountNonExpired()`, `isAccountNonLocked()`, `isCredentialsNonExpired()`, `isEnabled()`: Returns the user's account status.

*Annotations*:
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.

*Fields*:
- `user`: User entity associated with this principal.

=== Client

[source,java]
----
@Entity
@Table(name = "clients")
@Getter
@Setter
public class Client {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String clientName;

    @Column(nullable = false)
    private String clientSecret;

    @Column(nullable = false)
    private String redirectUri;
}
----

*Purpose*: Entity representing an OAuth client.

*Annotations*:
- `@Entity`: Specifies that the class is an entity.
- `@Table`: Specifies the primary table for the annotated entity.
- `@Getter`, `@Setter`: Lombok annotations to generate getters and setters.

*Fields*:
- `id`: Primary key of the client.
- `clientName`: Name of the client.
- `clientSecret`: Secret used for client authentication.
- `redirectUri`: URI to redirect after authentication.

=== Role

[source,java]
----
@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @ManyToMany(mappedBy = "roles")
    private Set<User> users;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Set<User> getUsers() {
        return users;
    }

    public void setUsers(Set<User> users) {
        this.users = users;
    }
}
----

*Purpose*: Entity representing a user role.

*Methods*:
- `getId()`, `setId(...)`, `getName()`, `setName(...)`, `getUsers()`, `setUsers(...)`: Getters and setters for the properties.

*Annotations*:
- `@Entity`: Specifies that the class is an entity.
- `@Table`: Specifies the primary table for the annotated entity.
- `@ManyToMany`: Defines a many-to-many relationship between the entities.

*Fields*:
- `id`: Primary key of the role.
- `name`: Name of the role.
- `users`: Users associated with this role.

=== Token

[source,java]
----
@Entity
@Table(name = "tokens")
@Getter
@Setter
public class Token {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String accessToken;

    @Column(nullable = false)
    private String refreshToken;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne
    @JoinColumn(name = "client_id", nullable = false)
    private Client client;
}
----

*Purpose*: Entity representing an OAuth token.

*Annotations*:
- `@Entity`: Specifies that the class is an entity.
- `@Table`: Specifies the primary table for the annotated entity.
- `@Getter`, `@Setter`: Lombok annotations to generate getters and setters.
- `@ManyToOne`: Defines a many-to-one relationship between the entities.
- `@JoinColumn`: Specifies a column for joining an entity association.

*Fields*:
- `id`: Primary key of the token.
- `accessToken`: Access token issued to the client.
- `refreshToken`: Refresh token issued to the client.
- `user`: User associated with this token.
- `client`: Client associated with this token.

=== User

[source,java]
----
@Entity
@Table(name = "users")
@Data
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false)
    private String email;

    @Column(nullable = false)
    private String passwordHash;

    @ManyToMany
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles;
}
----

*Purpose*: Entity representing a user.

*Annotations*:
- `@Entity`: Specifies that the class is an entity.
- `@Table`: Specifies the primary table for the annotated entity.
- `@Data`: Lombok annotation to create getters, setters, `toString`, `equals`, and `hashCode` methods.
- `@ManyToMany`: Defines a many-to-many relationship between the entities.
- `@JoinTable`: Specifies the join table for a many-to-many relationship.

*Fields*:
- `id`: Primary key of the user.
- `username`: Username of the user.
- `email`: Email address of the user.
- `passwordHash`: Hashed password of the user.
- `roles`: Roles assigned to the user.

=== UserRepository

[source,java]
----
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
----

*Purpose*: Repository interface for user entity.

*Annotations*:
- `@Repository`: Marks the interface as a Spring Data repository.

=== AuditService

[source,java]
----
@Service
public class AuditService {
    public void logEvent(String event) {
        // Implementation details
    }
}
----

*Purpose*: Service for logging audit events.

*Methods*:
- `logEvent(String event)`: Logs an audit event.

*Annotations*:
- `@Service`: Marks this class as a Spring-managed service.

=== EmailService

[source,java]
----
@Service
public class EmailService {
    @Autowired
    private final NotificationService notificationService;

    public void sendWelcomeEmail(String to) {
        // Implementation details
    }
}
----

*Purpose*: Service for sending emails.

*Methods*:
- `sendWelcomeEmail(String to)`: Sends a welcome email to the specified address.

*Annotations*:
- `@Service`: Marks this class as a Spring-managed service.

*Fields*:
- `notificationService`: Service for sending notifications.

=== JWTService

[source,java]
----
@Service
@Slf4j
public class JWTService {
    @Autowired
    private final AuditService auditService;

    @Autowired
    private final TokenBlacklistService tokenBlacklistService;

    private final Key secretKey;

    public String extractUsername(String token) {
        // Implementation details
    }

    public String generateToken(final String username) {
        // Implementation details
    }

    public boolean validateToken(String token) {
        // Implementation details
    }

    public void invalidateToken(String token) {
        tokenBlacklistService.blacklistToken(token);
    }
}
----

*Purpose*: Service for handling JWT operations.

*Methods*:
- `extractUsername(String token)`: Extracts the username from the token.
- `generateToken(String username)`: Generates a new token for the specified username.
- `validateToken(String token)`: Validates the specified token.
- `invalidateToken(String token)`: Invalidates the specified token.

*Annotations*:
- `@Service`: Marks this class as a Spring-managed service.
- `@Slf4j`: Provides logging capability.

*Fields*:
- `auditService`: Service for logging audit events.
- `tokenBlacklistService`: Service for blacklisting tokens.
- `secretKey`: Key used for signing tokens.

=== NotificationService

[source,java]
----
@Service
public class NotificationService {
    public void notifyUser(String user, String message) {
        // Implementation details
    }
}
----

*Purpose*: Service for sending notifications to users.

*Methods*:
- `notifyUser(String user, String message)`: Sends a notification to the specified user.

*Annotations*:
- `@Service`: Marks this class as a Spring-managed service.

=== TokenBlacklistService

[source,java]
----
@Service
public class TokenBlacklistService {
    public void blacklistToken(String token) {
        // Implementation details
    }
}
----

*Purpose*: Service for blacklisting tokens.

*Methods*:
- `blacklistToken(String token)`: Adds the specified token to the blacklist.

*Annotations*:
- `@Service`: Marks this class as a Spring-managed service.

=== UserService

[source,java]
----
@Service
public class UserService implements UserDetailsService {
    @Autowired
    private AuditService auditService;

    @Autowired
    private EmailService emailService;

    @Autowired
    private BCryptPasswordEncoder encoder;

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(final String username) throws UsernameNotFoundException {
        // Implementation details
    }

    public Users register(final Users user) {
        // Implementation details
    }
}
----

*Purpose*: Service for user-related operations.

*Methods*:
- `loadUserByUsername(String username)`: Loads user details by username.
- `register(Users user)`: Registers a new user.

*Annotations*:
- `@Service`: Marks this class as a Spring-managed service.
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.

*Fields*:
- `auditService`: Service for logging audit events.
- `emailService`: Service for sending emails.
- `encoder`: Password encoder for hashing passwords.
- `userRepository`: Repository for accessing user data.

=== IdentityproviderApplicationTests

[source,java]
----
@SpringBootTest
public class IdentityproviderApplicationTests {

    @Test
    public void contextLoads() {
    }
}
----

*Purpose*: Test class for the Spring Boot application.

*Methods*:
- `contextLoads()`: Test method to ensure the Spring context loads properly.

*Annotations*:
- `@SpringBootTest`: Marks the class as a Spring Boot test class.
- `@Test`: Marks the method as a test method.

== Runtime View Diagrams

=== User Registration Flow

[source,plantuml]
----
@startuml
actor User
participant UserController
participant UserService
participant UserRepository
participant EmailService
participant AuditService

User -> UserController : register(user)
UserController -> UserService : register(user)
UserService -> UserRepository : save(user)
UserRepository -> UserService : userSaved
UserService -> EmailService : sendWelcomeEmail(user.email)
EmailService -> UserService : emailSent
UserService -> AuditService : logEvent("User registered")
AuditService -> UserService : eventLogged
UserService -> UserController : user
UserController -> User : user
@enduml
----

=== Authentication/Login Flow

[source,plantuml]
----
@startuml
actor User
participant UserController
participant UserService
participant JWTService
participant AuditService

User -> UserController : login(authRequest)
UserController -> UserService : loadUserByUsername(authRequest.username)
UserService -> UserController : userDetails
UserController -> JWTService : generateToken(userDetails.username)
JWTService -> UserController : token
UserController -> AuditService : logEvent("User logged in")
AuditService -> UserController : eventLogged
UserController -> User : token
@enduml
----

=== JWT Token Validation Flow

[source,plantuml]
----
@startuml
actor User
participant JwtAuthFilter
participant JWTService
participant AuditService

User -> JwtAuthFilter : request(resource)
JwtAuthFilter -> JWTService : validateToken(token)
JWTService -> JwtAuthFilter : isValid
alt isValid
    JwtAuthFilter -> User : proceed
else not isValid
    JwtAuthFilter -> AuditService : logEvent("Invalid token attempt")
    AuditService -> JwtAuthFilter : eventLogged
    JwtAuthFilter -> User : unauthorized
end
@enduml
----

=== Exception Handling Flow

[source,plantuml]
----
@startuml
actor User
participant UserController
participant UserService
participant EmailService
participant AuditService

User -> UserController : action()
alt success
    UserController -> UserService : performAction()
    UserService -> UserController : result
    UserController -> User : result
else exception
    UserController -> AuditService : logEvent("Exception occurred")
    AuditService -> UserController : eventLogged
    UserController -> User : errorResponse
end
@enduml
----

== Entity Relationship Diagram

[source,plantuml]
----
@startuml
entity User {
    * id : Long
    * username : String
    * email : String
    * passwordHash : String
    --
    * roles : Set<Role>
}

entity Role {
    * id : Long
    * name : String
    --
    * users : Set<User>
}

entity Client {
    * id : Long
    * clientName : String
    * clientSecret : String
    * redirectUri : String
}

entity Token {
    * id : Long
    * accessToken : String
    * refreshToken : String
    --
    * user : User
    * client : Client
}

User "1" -- "many" Role : has >
Role "many" -- "1" User : belongs to <
User "1" -- "many" Token : has >
Token "many" -- "1" User : belongs to <
Client "1" -- "many" Token : has >
Token "many" -- "1" Client : belongs to <
@enduml
----

*User*: Represents a user in the system. Each user has a unique username and email. Users are associated with roles and tokens.

*Role*: Represents a role in the system. Each role has a unique name and is associated with multiple users.

*Client*: Represents an OAuth client. Each client has a unique client name and secret. Clients are associated with tokens.

*Token