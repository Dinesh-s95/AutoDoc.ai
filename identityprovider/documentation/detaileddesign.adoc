= Identity Provider Detailed Design Documentation

This document provides a comprehensive detailed design overview of the Identity Provider system implemented using Java Spring Boot. It includes class-by-class analysis, runtime view diagrams, entity relationship diagrams, and detailed component interactions.

== Class-by-Class Analysis

=== IdentityproviderApplication

[source,java]
----
@SpringBootApplication
public class IdentityproviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(IdentityproviderApplication.class, args);
    }
}
----

*Purpose*: This is the main class that boots up the Spring Boot application.

*Annotations*:
- `@SpringBootApplication`: Serves as a convenience annotation that adds all of the following:
  - `@Configuration`: Tags the class as a source of bean definitions for the application context.
  - `@EnableAutoConfiguration`: Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings.
  - `@ComponentScan`: Tells Spring to look for other components, configurations, and services in the specified package, allowing it to find and register the controllers.

*Methods*:
- `main(String[] args)`: The entry point of the Spring Boot application which launches the application context.

=== JwtAuthFilter

[source,java]
----
@Component
@Slf4j
public class JwtAuthFilter extends OncePerRequestFilter {
    @Autowired
    private UserService userService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // Implementation details
    }
}
----

*Purpose*: Intercepts HTTP requests to check for the presence of a JWT (JSON Web Token) in the header and validates it.

*Annotations*:
- `@Component`: Indicates that the class is a Spring component.
- `@Slf4j`: Lombok annotation to provide `Slf4j` logging facility.

*Methods*:
- `doFilterInternal(...)`: Checks each request for a valid JWT and proceeds with the filter chain if the token is valid.

*Fields*:
- `userService`: Autowired service to manage user-related operations, possibly used for user authentication and details retrieval.

=== SecurityConfig

[source,java]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Autowired
    private JwtAuthFilter jwtAuthFilter;
    @Autowired
    private UserDetailsService userDetailsService;

    @Bean
    public AuthenticationManager authenticationManager(final AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        // Implementation details
    }

    @Bean
    public SecurityFilterChain securityFilterChain(final HttpSecurity http) throws Exception {
        // Implementation details
    }
}
----

*Purpose*: Configures the security settings for the application, including the authentication manager, authentication provider, and security filters.

*Annotations*:
- `@Configuration`: Indicates that the class declares one or more `@Bean` methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime.
- `@EnableWebSecurity`: Allows Spring to find and automatically apply the class to the global Web Security.

*Methods*:
- `authenticationManager(...)`: Defines the authentication manager bean.
- `authenticationProvider(...)`: Defines the authentication provider bean.
- `securityFilterChain(...)`: Configures the security filter chain which includes custom filters such as `jwtAuthFilter`.

*Fields*:
- `jwtAuthFilter`: The JWT authentication filter.
- `userDetailsService`: Service to load user-specific data.

=== UserController

[source,java]
----
@RestController
@RequestMapping("/idp/users")
public class UserController {
    @Autowired
    private AuthenticationManager authManager;
    @Autowired
    private JWTService jwtService;
    @Autowired
    private UserService userService;

    @PostMapping("/login")
    public ResponseEntity<Object> login(@RequestBody final Users user) {
        // Implementation details
    }

    @PostMapping("/register")
    public Users registerUser(@RequestBody final Users user) {
        // Implementation details
    }
}
----

*Purpose*: Handles all user-related actions such as registration and login.

*Annotations*:
- `@RestController`: Marks the class as a controller where every method returns a domain object instead of a view.
- `@RequestMapping("/idp/users")`: Maps web requests onto methods in request-handling classes with flexible method signatures.
- `@PostMapping(...)`: Annotation for mapping HTTP POST requests onto specific handler methods.

*Methods*:
- `login(...)`: Authenticates a user and returns a JWT.
- `registerUser(...)`: Registers a new user in the system.

*Fields*:
- `authManager`: Manages authentication within the application.
- `jwtService`: Service to handle JWT creation and validation.
- `userService`: Service to handle user-related business logic.

== Runtime View Diagrams

=== User Registration Flow

[plantuml, user-registration-sequence, png]
----
@startuml
actor "User" as U
participant "UserController" as UC
participant "UserService" as US
participant "JWTService" as JS
participant "Database" as DB

U -> UC : register(user)
activate UC
UC -> US : register(user)
activate US
US -> DB : save(user)
activate DB
DB --> US : user
deactivate DB
US --> UC : user
deactivate US
UC -> JS : generateToken(user.username)
activate JS
JS --> UC : token
deactivate JS
UC --> U : token
deactivate UC
@enduml
----

=== Authentication/Login Flow

[plantuml, authentication-sequence, png]
----
@startuml
actor "User" as U
participant "UserController" as UC
participant "AuthenticationManager" as AM
participant "JWTService" as JS

U -> UC : login(username, password)
activate UC
UC -> AM : authenticate(username, password)
activate AM
AM --> UC : isAuthenticated
deactivate AM
UC -> JS : generateToken(username)
activate JS
JS --> UC : token
deactivate JS
UC --> U : token
deactivate UC
@enduml
----

=== JWT Token Validation Flow

[plantuml, jwt-validation-sequence, png]
----
@startuml
actor "User" as U
participant "JwtAuthFilter" as JF
participant "JWTService" as JS

U -> JF : request(resource)
activate JF
JF -> JS : validateToken(token)
activate JS
JS --> JF : isValid
deactivate JS
JF --> U : proceed / error
deactivate JF
@enduml
----

=== Exception Handling Flow

[plantuml, exception-handling-sequence, png]
----
@startuml
actor "User" as U
participant "UserController" as UC
participant "UserService" as US
participant "Database" as DB

U -> UC : action()
activate UC
UC -> US : performAction()
activate US
US -> DB : query()
activate DB
alt successful query
    DB --> US : result
else exception occurs
    DB --> US : throw new DatabaseException()
    US --> UC : throw new ServiceException()
    UC --> U : return "Error occurred"
end
deactivate DB
deactivate US
deactivate UC
@enduml
----

== Entity Relationship Diagram

[plantuml, er-diagram, png]
----
@startuml
entity "User" {
    * id : Long
    --
    * username : String
    * email : String
    * passwordHash : String
    * roles : Set<Role>
}

entity "Role" {
    * id : Long
    --
    * name : String
    * users : Set<User>
}

entity "Client" {
    * id : Long
    --
    * clientName : String
    * clientSecret : String
    * redirectUri : String
}

entity "Token" {
    * id : Long
    --
    * accessToken : String
    * refreshToken : String
    * user : User
    * client : Client
}

User "1" -- "*" Role : has >
Role "1" -- "*" User : belongs to >
User "1" -- "*" Token : owns >
Client "1" -- "*" Token : issued >
@enduml
----

*Entities*:
- **User**: Represents a user in the system with attributes like username, email, and passwordHash. It has a many-to-many relationship with the Role entity and a one-to-many relationship with the Token entity.
- **Role**: Represents the role or authority a user holds. It has a many-to-many relationship with the User entity.
- **Client**: Represents an OAuth client with attributes like clientName, clientSecret, and redirectUri. It has a one-to-many relationship with the Token entity.
- **Token**: Represents an authentication token (access and refresh) associated with a user and a client.

== Detailed Component Interactions

=== Controller-Service-Repository Interactions

*UserController* -> *UserService* -> *UserRepository*:
- The UserController receives HTTP requests and delegates business logic execution to the UserService. The UserService interacts with the UserRepository to perform data access operations on the database.

=== Data Flow Through Layers

1. **Controller Layer**: Receives HTTP requests and delegates to service layer.
2. **Service Layer**: Handles business logic and calls on the repository layer for data.
3. **Repository Layer**: Performs CRUD operations on the database.

=== Exception Propagation

Exceptions are generated in the repository layer (e.g., database errors), propagated to the service layer (where they can be logged or transformed), and then to the controller layer where they are handled and an appropriate HTTP response is generated.

=== Transaction Boundaries

Transactions are typically started at the service layer to ensure data integrity and consistency during operations that involve multiple steps or queries. This encapsulates business logic within transactional boundaries.

This detailed design document provides a comprehensive overview of the Identity Provider system, ensuring developers have a clear understanding of the system's architecture, data flow, and interactions.