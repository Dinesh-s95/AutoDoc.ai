= Detailed Design Documentation: Identity Provider Application

This document provides a comprehensive detailed design overview of the Identity Provider Application, developed using Java Spring Boot. It includes class-by-class analysis, runtime view diagrams, entity relationship diagrams, and detailed component interactions.

== 1. Class-by-Class Analysis

=== IdentityproviderApplication

*Purpose*: Serves as the entry point of the Spring Boot application.

*Methods*:
- `public static void main(String[] args)`: Initializes the Spring Boot application.

*Annotations*:
- `@SpringBootApplication`: Indicates that the class is a Spring Boot application.

=== JwtAuthFilter

*Purpose*: Filters incoming requests and manages JWT authentication.

*Methods*:
- `protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)`: Filters requests to check for valid JWT tokens.

*Annotations*:
- `@Autowired`: Automatically injects the required dependencies.
- `@Component`: Marks the class as a Spring component.
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.
- `@Slf4j`: Provides a simple logging facade.

*Fields*:
- `userService : UserService`: Service used to interact with user data.

=== SecurityConfig

*Purpose*: Configures security-related aspects of the application, such as authentication and authorization.

*Methods*:
- `AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig)`: Provides the authentication manager bean.
- `AuthenticationProvider authenticationProvider()`: Provides the authentication provider bean.
- `SecurityFilterChain securityFilterChain(HttpSecurity http)`: Configures the security filter chain.

*Annotations*:
- `@Autowired`: Injects other components.
- `@Bean`: Indicates that a method produces a bean to be managed by the Spring container.
- `@Configuration`: Indicates that the class has @Bean definition methods.
- `@EnableWebSecurity`: Adds Spring Security configuration.

*Fields*:
- `jwtAuthFilter : JwtAuthFilter`: JWT authentication filter.
- `userDetailsService : UserDetailsService`: Service to load user-specific data.

=== UserController

*Purpose*: Handles user-related operations such as registration and login.

*Methods*:
- `ResponseEntity<Object> login(Users user)`: Manages user login.
- `Users registerUser(Users user)`: Handles user registration.

*Annotations*:
- `@Autowired`: Injects other components.
- `@PostMapping`: Marks methods as handling POST requests.
- `@RequestBody`: Indicates a method parameter should be bound to the body of the HTTP request.
- `@RequestMapping`: Maps HTTP requests to handler methods.
- `@RestController`: Marks the class as a controller where every method returns a domain object instead of a view.

*Fields*:
- `authManager : AuthenticationManager`: Authentication manager for login.
- `jwtService : JWTService`: Service for JWT operations.
- `userService : UserService`: Service for user operations.

=== AuthRequest

*Purpose*: Represents the authentication request.

*Annotations*:
- `@Data`: A convenient shortcut annotation that bundles the features of `@ToString`, `@EqualsAndHashCode`, `@Getter` / `@Setter` and `@RequiredArgsConstructor` together.

*Fields*:
- `password : String`: User's password.
- `username : String`: User's username.

=== AuthResponse

*Purpose*: Represents the authentication response.

*Fields*: None

=== UserPrincipal

*Purpose*: Provides user details to Spring Security.

*Methods*:
- Various `@Override` methods to provide user details and authentication settings.

*Fields*:
- `user : final Users`: The user entity associated with the principal.

=== Client

*Purpose*: Represents a client application that can request tokens.

*Annotations*:
- `@Entity`: Marks the class as a JPA entity.
- `@Table`: Specifies the table in the database for this entity.
- `@Id`, `@GeneratedValue`: Annotations for the primary key and its generation strategy.
- `@Column`: Marks a field to be mapped to a column in the database.
- `@Getter`, `@Setter`: Lombok annotations to generate getters and setters.

*Fields*:
- `clientName : String`: Name of the client.
- `clientSecret : String`: Secret used for client authentication.
- `id : Long`: Primary key.
- `redirectUri : String`: URI to redirect after authentication.

=== Role

*Purpose*: Represents a security role within the application.

*Annotations*:
- `@Entity`, `@Table`, `@Id`, `@GeneratedValue`, `@Column`: Standard JPA and database mapping annotations.
- `@ManyToMany`: Indicates a many-to-many relationship with the `User` entity.

*Methods*:
- Getters and setters for ID, name, and users.

*Fields*:
- `id : Long`: Primary key.
- `name : String`: Name of the role.
- `users : Set<User>`: Users associated with this role.

=== Token

*Purpose*: Represents an authentication token.

*Annotations*:
- `@Entity`, `@Table`, `@Id`, `@GeneratedValue`, `@Column`, `@Getter`, `@Setter`: Standard JPA and database mapping annotations.
- `@ManyToOne`, `@JoinColumn`: Indicates a many-to-one relationship with another entity.

*Fields*:
- `accessToken : String`: Access token string.
- `client : Client`: Associated client.
- `id : Long`: Primary key.
- `refreshToken : String`: Refresh token string.
- `user : User`: Associated user.

=== User

*Purpose*: Represents a user of the system.

*Annotations*:
- `@Entity`, `@Table`, `@Id`, `@GeneratedValue`, `@Column`, `@Data`, `@Getter`, `@Setter`: Standard JPA and database mapping annotations.
- `@ManyToMany`, `@JoinTable`, `@JoinColumn`: Annotations for handling relationships and join tables.

*Fields*:
- `email : String`: User's email.
- `id : Long`: Primary key.
- `passwordHash : String`: Hash of the user's password.
- `roles : Set<Role>`: Security roles associated with the user.
- `username : String`: User's username.

=== UserRepository

*Purpose*: Repository for accessing user data.

*Annotations*:
- `@Repository`: Marks the class as a Spring Data repository.

=== AuditService

*Purpose*: Provides functionality to log audit events.

*Methods*:
- `public void logEvent(String event)`: Logs an audit event.

*Annotations*:
- `@Service`: Marks the class as a Spring service.

=== EmailService

*Purpose*: Manages sending emails.

*Methods*:
- `public void sendWelcomeEmail(String to)`: Sends a welcome email.

*Annotations*:
- `@Service`: Marks the class as a Spring service.

*Fields*:
- `notificationService : final NotificationService`: Service used for sending notifications.

=== JWTService

*Purpose*: Manages JWT operations such as creation, extraction, and validation.

*Methods*:
- `public String extractUsername(String token)`: Extracts the username from the token.
- `public String generateToken(String username)`: Generates a new token.
- `public boolean validateToken(String token)`: Validates a token.
- `public void invalidateToken(String token)`: Invalidates a token.

*Annotations*:
- `@Service`: Marks the class as a Spring service.
- `@Slf4j`: Provides a simple logging facade.

*Fields*:
- `auditService : final AuditService`: Audit service for logging.
- `secretKey : final Key`: Secret key used for token generation.
- `tokenBlacklistService : final TokenBlacklistService`: Service for handling blacklisted tokens.

=== NotificationService

*Purpose*: Provides notification services.

*Methods*:
- `public void notifyUser(String user, String message)`: Sends a notification to a user.

*Annotations*:
- `@Service`: Marks the class as a Spring service.

=== TokenBlacklistService

*Purpose*: Manages blacklisted tokens.

*Methods*:
- `public void blacklistToken(String token)`: Adds a token to the blacklist.

*Annotations*:
- `@Service`: Marks the class as a Spring service.

=== UserService

*Purpose*: Provides user-related services.

*Methods*:
- `public UserDetails loadUserByUsername(String username)`: Loads user details by username.
- `public Users register(Users user)`: Registers a new user.

*Annotations*:
- `@Autowired`: Automatically injects the required dependencies.
- `@Override`: Indicates that a method declaration is intended to override a method declaration in a supertype.
- `@Service`: Marks the class as a Spring service.

*Fields*:
- `auditService : AuditService`: Service for auditing.
- `emailService : EmailService`: Service for email management.
- `encoder : BCryptPasswordEncoder`: Password encoder.
- `userRepository : UserRepository`: Repository for accessing user data.

=== IdentityproviderApplicationTests

*Purpose*: Contains tests for the Identity Provider Application.

*Annotations*:
- `@SpringBootTest`: Indicates that the class should bootstrap the application for testing.
- `@Test`: Indicates that the method is a test method.

== 2. Runtime View Diagrams

=== User Registration Flow

[plantuml, user-registration-sequence, png]
----
@startuml
actor User
participant UserController
participant UserService
participant UserRepository
participant EmailService

User -> UserController : register(user)
activate UserController
UserController -> UserService : register(user)
activate UserService
UserService -> UserRepository : save(user)
activate UserRepository
UserRepository -> UserService : userSaved
deactivate UserRepository
UserService -> EmailService : sendWelcomeEmail(user.email)
activate EmailService
EmailService -> UserService : emailSent
deactivate EmailService
UserService -> UserController : user
deactivate UserService
UserController -> User : user
deactivate UserController
@enduml
----

=== Authentication/Login Flow

[plantuml, user-login-sequence, png]
----
@startuml
actor User
participant UserController
participant UserService
participant JWTService

User -> UserController : login(user)
activate UserController
UserController -> UserService : loadUserByUsername(user.username)
activate UserService
UserService -> UserController : userDetails
deactivate UserService
UserController -> JWTService : generateToken(userDetails.username)
activate JWTService
JWTService -> UserController : token
deactivate JWTService
UserController -> User : token
deactivate UserController
@enduml
----

=== JWT Token Validation Flow

[plantuml, jwt-validation-sequence, png]
----
@startuml
actor User
participant JwtAuthFilter
participant JWTService

User -> JwtAuthFilter : request(resource)
activate JwtAuthFilter
JwtAuthFilter -> JWTService : validateToken(token)
activate JWTService
JWTService -> JwtAuthFilter : isValid
deactivate JWTService
JwtAuthFilter -> User : proceed / error
deactivate JwtAuthFilter
@enduml
----

=== Business Process Flow

[plantuml, business-process-flow, png]
----
@startuml
actor Client
participant UserController
participant UserService
participant AuditService

Client -> UserController : performAction()
activate UserController
UserController -> UserService : processAction()
activate UserService
UserService -> AuditService : logEvent("Action processed")
activate AuditService
AuditService -> UserService : logged
deactivate AuditService
UserService -> UserController : result
deactivate UserService
UserController -> Client : result
deactivate UserController
@enduml
----

=== Exception Handling Flow

[plantuml, exception-handling-flow, png]
----
@startuml
actor User
participant UserController
participant UserService
participant "ExceptionHandler"

User -> UserController : request()
activate UserController
alt success
    UserController -> UserService : processRequest()
    activate UserService
    UserService -> UserController : response
    deactivate UserService
    UserController -> User : response
else exception
    UserController -> UserService : processRequest()
    activate UserService
    UserService -> UserController : throw new Exception()
    deactivate UserService
    UserController -> "ExceptionHandler" : handleException()
    activate "ExceptionHandler"
    "ExceptionHandler" -> UserController : errorResponse
    deactivate "ExceptionHandler"
    UserController -> User : errorResponse
end
deactivate UserController
@enduml
----

== 3. Entity Relationship Diagram

[plantuml, er-diagram, png]
----
@startuml
entity "User" {
    * id : Long
    --
    * username : String
    * email : String
    * passwordHash : String
    * roles : Set<Role>
}

entity "Role" {
    * id : Long
    --
    * name : String
    * users : Set<User>
}

entity "Client" {
    * id : Long
    --
    * clientName : String
    * clientSecret : String
    * redirectUri : String
}

entity "Token" {
    * id : Long
    --
    * accessToken : String
    * refreshToken : String
    * user : User
    * client : Client
}

User "1" -- "0..*" Role
Role "1" -- "0..*" User
User "1" -- "0..*" Token
Client "1" -- "0..*" Token
@enduml
----

*User*: Represents a user of the system. Each user has a unique ID, username, email, and password hash. Users are associated with one or more roles and can have multiple tokens.

*Role*: Represents a security role. Each role has a unique ID and name. Roles are associated with multiple users.

*Client*: Represents a client application that can request tokens. Each client has a unique ID, name, secret, and redirect URI.

*Token*: Represents an authentication token. Each token has a unique ID, access token string, refresh token string, and is associated with a user and a client.

== 4. Detailed Component Interactions

=== Controller-Service-Repository Interactions

*UserController* interacts with *UserService* for user-related operations. *UserService* then interacts with *UserRepository* to persist data. For instance, during user registration, *UserController* calls *UserService.register*, which in turn uses *UserRepository.save* to store the user data.

=== Data Flow Through Layers

Data flows from the controllers to services and then to repositories. For example, in the login flow, *UserController* receives the login request, which is handled by *UserService* to load user details from *UserRepository*. The response flows back through the same path to the user.

=== Exception Propagation

Exceptions are propagated from the repositories to services and then to controllers where they are handled by an exception handler. This handler decides the HTTP response to be returned to the client.

=== Transaction Boundaries

Transactions are typically started at the service layer. This ensures that all operations performed within a single method are completed successfully before the transaction is committed. If an exception occurs, the transaction is rolled back.

This detailed design document provides a comprehensive overview of the Identity Provider Application, enabling developers to understand and work effectively with the codebase.